println("Hello world!\n");

const IS_RISCV = True;


enum Option<T> {
    Some(T),
    Nothing
}

enum Result<T, E> {
    Ok(T),
    Err(E)
}

def panic(): ! {
    println("Panic!\n");
    debug();
    while True {}
}

impl Result<T, E> {
    def is_ok(self: Result<T, E>): Bool {
        match self {
            of Ok(_) => True,
            _ => False
        }
    }

    def is_err(self: Result<T, E>): Bool {
        match self {
            of Err(_) => True,
            _ => False
        }
    }

    def unwrap(self: Result<T, E>): T {
        match self {
            of Ok(x) => x,
            _ => {
                println("[Error] Called unwrap() on Err value: \n", self);
                panic();
            }
        }
    }

    def unwrap_err(self: Result<T, E>): E {
        match self {
            of Err(x) => x,
            _ => {
                println("[Error] Called unwrap_err() on Ok value: \n", self);
                panic();
            }
        }
    }

    def expect(self: Result<T, E>, msg: &Char): T {
        match self {
            of Ok(x) => x,
            _ => {
                println("[Error] ", msg, "\n");
                println("[Error] Called expect() on Err value: \n", self);
                panic();
            }
        }
    }

    def ok(self: Result<T, E>): Option<T> {
        match self {
            of Ok(x) => Option<T> of Some(x),
            _ => Option<T> of Nothing
        }
    }

    def err(self: Result<T, E>): Option<E> {
        match self {
            of Err(x) => Option<E> of Some(x),
            _ => Option<E> of Nothing
        }
    }

    def unwrap_or(self: Result<T, E>, default: T): T {
        match self {
            of Ok(x) => x,
            _ => default
        }
    }

    def map<U>(self: Result<T, E>, f: T -> U): Result<U, E> {
        match self {
            of Ok(x) => Result<U, E> of Ok(f(x)),
            of Err(x) => Result<U, E> of Err(x),
            _ => {
                println("[Error] Called map() on Err value: \n", self);
                panic();
            }
        }
    }
}

const BITMAP_WIDTH = 8;
const BITMAP_HEIGHT = 8;

struct Bitmap {
    pixels: [[Bool * BITMAP_WIDTH] * BITMAP_HEIGHT]
}

const __ = False;
const XX = True;

impl Bitmap {
    const WIDTH = BITMAP_WIDTH;
    const HEIGHT = BITMAP_HEIGHT;

    const SPACE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const TOP_LEFT_CORNER = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, XX, XX, XX],
            [__, __, __, XX, XX, XX, XX, XX],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };

    const TOP_RIGHT_CORNER = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [XX, XX, XX, XX, XX, __, __, __],
            [XX, XX, XX, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };

    const BOTTOM_LEFT_CORNER = {
        pixels = [
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, XX, XX, XX],
            [__, __, __, XX, XX, XX, XX, XX],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const BOTTOM_RIGHT_CORNER = {
        pixels = [
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [XX, XX, XX, XX, XX, __, __, __],
            [XX, XX, XX, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

            
    const ERROR = {
        pixels = [
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, __, __, __, __, XX, XX],
            [XX, __, XX, __, __, XX, __, XX],
            [XX, __, __, XX, XX, __, __, XX],
            [XX, __, __, XX, XX, __, __, XX],
            [XX, __, XX, __, __, XX, __, XX],
            [XX, XX, __, __, __, __, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
        ]
    };

    const UPPER_A = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_B = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_C = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_D = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_E = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_F = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_G = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, XX, XX, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_H = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_I = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_J = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, XX, __, __, __, XX, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_K = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, XX, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, XX, __, XX, __, __, __, __],
            [__, XX, XX, __, __, __, __, __],
            [__, XX, __, XX, __, __, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_L = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_M = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, __, __, XX, XX, __],
            [__, XX, __, XX, XX, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_N = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, __, __, __, XX, __],
            [__, XX, __, XX, __, __, XX, __],
            [__, XX, __, __, XX, __, XX, __],
            [__, XX, __, __, __, XX, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_O = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_P = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_Q = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, XX, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __]
        ]
    };

    const UPPER_R = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, XX, __, __, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, __, __, __, __, XX, __, __]
        ]
    };

    const UPPER_S = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, __, __, __, __, XX, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_T = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_U = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_V = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_W = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, XX, XX, __, XX, __],
            [__, XX, XX, __, __, XX, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_X = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_Y = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const UPPER_Z = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const LOWER_A = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const LOWER_B = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const LOWER_C = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    
    const LOWER_D = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const LOWER_E = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const LOWER_F = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, XX, XX, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };
    const LOWER_G = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };

    const LOWER_H = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_I = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_J = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, XX, XX, __, __, __, __],
        ]
    };

    const LOWER_K = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, XX, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_L = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_M = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, __, XX, __, __],
            [__, __, XX, __, XX, __, XX, __],
            [__, __, XX, __, XX, __, XX, __],
            [__, __, XX, __, XX, __, XX, __],
            [__, __, XX, __, XX, __, XX, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_N = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_O = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_P = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
        ]
    };

    const LOWER_Q = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
        ]
    };

    const LOWER_R = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, XX, XX, __, __],
            [__, __, XX, XX, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_S = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_T = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const LOWER_U = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_V = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_W = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, __, XX, __],
            [__, __, XX, __, __, __, XX, __],
            [__, __, XX, __, XX, __, XX, __],
            [__, __, XX, __, XX, __, XX, __],
            [__, __, __, XX, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const LOWER_X = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, __, XX, __],
            [__, __, __, XX, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, XX, __, __],
            [__, __, XX, __, __, __, XX, __],
        ]
    };

    const LOWER_Y = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };

    const LOWER_Z = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_0 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, XX, XX, __],
            [__, XX, __, __, XX, __, XX, __],
            [__, XX, __, XX, __, __, XX, __],
            [__, XX, XX, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __]
        ]
    };

    const NUM_1 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_2 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_3 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_4 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, XX, __, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_5 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_6 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_7 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_8 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const NUM_9 = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_EXCLAMATION = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };

    const PUNC_QUOTE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, __, XX, XX, __, __],
            [__, XX, XX, __, XX, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_HASH = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_DOLLAR = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, XX, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, XX, __, XX, __, __],
            [__, XX, XX, XX, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
        ]
    };

    const PUNC_PERCENT = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, __, __, __, XX, __],
            [__, XX, XX, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, __, __, XX, XX, __],
            [__, XX, __, __, __, XX, XX, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_AMPERSAND = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, __, __, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, __, XX, XX, __, __, XX, __],
            [__, XX, __, XX, __, XX, __, __],
            [__, XX, __, __, XX, __, __, __],
            [__, __, XX, XX, __, XX, __, __],
        ]
    };

    const PUNC_APOSTROPHE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_LEFT_PAREN = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
        ]
    };


    const PUNC_RIGHT_PAREN = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
        ]
    };

    const PUNC_ASTERISK = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_ADD = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_COMMA = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, __, __, __, __, __],
            [__, XX, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
        ]
    };

    const PUNC_DASH = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_PERIOD = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, __, __, __, __, __],
            [__, XX, XX, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };
    const PUNC_FORWARD_SLASH = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_COLON = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_SEMICOLON = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, XX, __, __, __],
        ]
    };

    const PUNC_LESS_THAN = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
        ]
    };

    const PUNC_EQUALS = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, XX, XX, XX, XX, XX, XX, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_GREATER_THAN = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
        ]
    };

    const PUNC_QUESTION = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, XX, __, __],
            [__, XX, __, __, __, __, XX, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
        ]
    };

    const PUNC_AT = {
        pixels = [
            [__, XX, XX, XX, XX, XX, XX, __],
            [XX, __, __, __, __, __, __, XX],
            [XX, __, __, XX, XX, __, __, XX],
            [XX, __, __, __, __, XX, __, XX],
            [XX, __, __, XX, XX, XX, __, XX],
            [XX, __, XX, __, __, XX, __, XX],
            [XX, __, __, XX, XX, XX, __, XX],
            [__, XX, XX, XX, XX, XX, XX, __]
        ]
    };

    const PUNC_LEFT_SQUARE_BRACE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, XX, XX, __, __, __],
        ]
    };

    const PUNC_BACK_SLASH = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __],
        ]
    };
    const PUNC_RIGHT_SQUARE_BRACE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, XX, XX, XX, __, __],
        ]
    };
    const PUNC_CARET = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, XX, __, __, __],
            [__, __, __, XX, __, XX, __, __],
            [__, __, XX, __, __, __, XX, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_UNDERSCORE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [XX, XX, XX, XX, XX, XX, XX, XX],
        ]
    };

    const PUNC_BACKTICK = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const PUNC_LEFT_CURLY_BRACE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, XX, __, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, XX, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };
    
    const PUNC_PIPE = {
        pixels = [
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
            [__, __, __, XX, __, __, __, __],
        ]
    };

    const PUNC_RIGHT_CULRY_BRACE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, XX, XX, __, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, __, XX, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, XX, XX, __, __, __],
        ]
    };

    const PUNC_TILDE = {
        pixels = [
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, XX, XX, __, __, __, __],
            [__, XX, XX, XX, XX, __, XX, __],
            [__, XX, __, __, XX, XX, XX, __],
            [__, __, __, __, __, XX, __, __],
            [__, __, __, __, __, __, __, __],
            [__, __, __, __, __, __, __, __],
        ]
    };

    const SOLID_BLOCK = {
        pixels = [
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX],
            [XX, XX, XX, XX, XX, XX, XX, XX]
        ]
    };

    const SPARSE_BLOCK = {
        pixels = [
            [XX, __, XX, __, XX, __, XX, __],
            [__, XX, __, XX, __, XX, __, XX],
            [XX, __, XX, __, XX, __, XX, __],
            [__, XX, __, XX, __, XX, __, XX],
            [XX, __, XX, __, XX, __, XX, __],
            [__, XX, __, XX, __, XX, __, XX],
            [XX, __, XX, __, XX, __, XX, __],
            [__, XX, __, XX, __, XX, __, XX],
        ]
    };

    const UPPER_ALPHABET = [
        Bitmap.UPPER_A,
        Bitmap.UPPER_B,
        Bitmap.UPPER_C,
        Bitmap.UPPER_D,
        Bitmap.UPPER_E,
        Bitmap.UPPER_F,
        Bitmap.UPPER_G,
        Bitmap.UPPER_H,
        Bitmap.UPPER_I,
        Bitmap.UPPER_J,
        Bitmap.UPPER_K,
        Bitmap.UPPER_L,
        Bitmap.UPPER_M,
        Bitmap.UPPER_N,
        Bitmap.UPPER_O,
        Bitmap.UPPER_P,
        Bitmap.UPPER_Q,
        Bitmap.UPPER_R,
        Bitmap.UPPER_S,
        Bitmap.UPPER_T,
        Bitmap.UPPER_U,
        Bitmap.UPPER_V,
        Bitmap.UPPER_W,
        Bitmap.UPPER_X,
        Bitmap.UPPER_Y,
        Bitmap.UPPER_Z
    ];

    const LOWER_ALPHABET = [
        Bitmap.LOWER_A,
        Bitmap.LOWER_B,
        Bitmap.LOWER_C,
        Bitmap.LOWER_D,
        Bitmap.LOWER_E,
        Bitmap.LOWER_F,
        Bitmap.LOWER_G,
        Bitmap.LOWER_H,
        Bitmap.LOWER_I,
        Bitmap.LOWER_J,
        Bitmap.LOWER_K,
        Bitmap.LOWER_L,
        Bitmap.LOWER_M,
        Bitmap.LOWER_N,
        Bitmap.LOWER_O,
        Bitmap.LOWER_P,
        Bitmap.LOWER_Q,
        Bitmap.LOWER_R,
        Bitmap.LOWER_S,
        Bitmap.LOWER_T,
        Bitmap.LOWER_U,
        Bitmap.LOWER_V,
        Bitmap.LOWER_W,
        Bitmap.LOWER_X,
        Bitmap.LOWER_Y,
        Bitmap.LOWER_Z
    ];

    const NUMBERS = [
        Bitmap.NUM_0,
        Bitmap.NUM_1,
        Bitmap.NUM_2,
        Bitmap.NUM_3,
        Bitmap.NUM_4,
        Bitmap.NUM_5,
        Bitmap.NUM_6,
        Bitmap.NUM_7,
        Bitmap.NUM_8,
        Bitmap.NUM_9
    ];

    const PUNCTUATION = [
        Bitmap.PUNC_EXCLAMATION,
        Bitmap.PUNC_QUOTE,
        Bitmap.PUNC_HASH,
        Bitmap.PUNC_DOLLAR,
        Bitmap.PUNC_PERCENT,
        Bitmap.PUNC_AMPERSAND,
        Bitmap.PUNC_APOSTROPHE,
        Bitmap.PUNC_LEFT_PAREN,
        Bitmap.PUNC_RIGHT_PAREN,
        Bitmap.PUNC_ASTERISK,
        Bitmap.PUNC_ADD,
        Bitmap.PUNC_COMMA,
        Bitmap.PUNC_DASH,
        Bitmap.PUNC_PERIOD,
        Bitmap.PUNC_FORWARD_SLASH,
        Bitmap.PUNC_COLON,
        Bitmap.PUNC_SEMICOLON,
        Bitmap.PUNC_LESS_THAN,
        Bitmap.PUNC_EQUALS,
        Bitmap.PUNC_GREATER_THAN,
        Bitmap.PUNC_QUESTION,
        Bitmap.PUNC_AT,
        Bitmap.PUNC_LEFT_SQUARE_BRACE,
        Bitmap.PUNC_BACK_SLASH,
        Bitmap.PUNC_RIGHT_SQUARE_BRACE,
        Bitmap.PUNC_CARET,
        Bitmap.PUNC_UNDERSCORE,
        Bitmap.PUNC_BACKTICK,
        Bitmap.PUNC_LEFT_CURLY_BRACE,
        Bitmap.PUNC_PIPE,
        Bitmap.PUNC_RIGHT_CULRY_BRACE,
        Bitmap.PUNC_TILDE
    ];

    def from_char(c: Char): Bitmap {
        // let sparse = 2 as Char;
        // let static SPARSE_BLOCK_CHAR: Char = sparse;
        // let solid = 1 as Char;
        // let static SOLID_BLOCK_CHAR: Char = solid;
        if c == 2 as Char {
            return Bitmap.SPARSE_BLOCK;
        }
        if c == 1 as Char {
            return Bitmap.SOLID_BLOCK;
        }
        match c {

            'A' => Bitmap.UPPER_A,
            'B' => Bitmap.UPPER_B,
            'C' => Bitmap.UPPER_C,
            'D' => Bitmap.UPPER_D,
            'E' => Bitmap.UPPER_E,
            'F' => Bitmap.UPPER_F,
            'G' => Bitmap.UPPER_G,
            'H' => Bitmap.UPPER_H,
            'I' => Bitmap.UPPER_I,
            'J' => Bitmap.UPPER_J,
            'K' => Bitmap.UPPER_K,
            'L' => Bitmap.UPPER_L,
            'M' => Bitmap.UPPER_M,
            'N' => Bitmap.UPPER_N,
            'O' => Bitmap.UPPER_O,
            'P' => Bitmap.UPPER_P,
            'Q' => Bitmap.UPPER_Q,
            'R' => Bitmap.UPPER_R,
            'S' => Bitmap.UPPER_S,
            'T' => Bitmap.UPPER_T,
            'U' => Bitmap.UPPER_U,
            'V' => Bitmap.UPPER_V,
            'W' => Bitmap.UPPER_W,
            'X' => Bitmap.UPPER_X,
            'Y' => Bitmap.UPPER_Y,
            'Z' => Bitmap.UPPER_Z,
            'a' => Bitmap.LOWER_A,
            'b' => Bitmap.LOWER_B,
            'c' => Bitmap.LOWER_C,
            'd' => Bitmap.LOWER_D,
            'e' => Bitmap.LOWER_E,
            'f' => Bitmap.LOWER_F,
            'g' => Bitmap.LOWER_G,
            'h' => Bitmap.LOWER_H,
            'i' => Bitmap.LOWER_I,
            'j' => Bitmap.LOWER_J,
            'k' => Bitmap.LOWER_K,
            'l' => Bitmap.LOWER_L,
            'm' => Bitmap.LOWER_M,
            'n' => Bitmap.LOWER_N,
            'o' => Bitmap.LOWER_O,
            'p' => Bitmap.LOWER_P,
            'q' => Bitmap.LOWER_Q,
            'r' => Bitmap.LOWER_R,
            's' => Bitmap.LOWER_S,
            't' => Bitmap.LOWER_T,
            'u' => Bitmap.LOWER_U,
            'v' => Bitmap.LOWER_V,
            'w' => Bitmap.LOWER_W,
            'x' => Bitmap.LOWER_X,
            'y' => Bitmap.LOWER_Y,
            'z' => Bitmap.LOWER_Z,
            '0' => Bitmap.NUM_0,
            '1' => Bitmap.NUM_1,
            '2' => Bitmap.NUM_2,
            '3' => Bitmap.NUM_3,
            '4' => Bitmap.NUM_4,
            '5' => Bitmap.NUM_5,
            '6' => Bitmap.NUM_6,
            '7' => Bitmap.NUM_7,
            '8' => Bitmap.NUM_8,
            '9' => Bitmap.NUM_9,
            '!' => Bitmap.PUNC_EXCLAMATION,
            '"' => Bitmap.PUNC_QUOTE,
            '#' => Bitmap.PUNC_HASH,
            '$' => Bitmap.PUNC_DOLLAR,
            '%' => Bitmap.PUNC_PERCENT,
            '&' => Bitmap.PUNC_AMPERSAND,
            '\'' => Bitmap.PUNC_APOSTROPHE,
            '(' => Bitmap.PUNC_LEFT_PAREN,
            ')' => Bitmap.PUNC_RIGHT_PAREN,
            '*' => Bitmap.PUNC_ASTERISK,
            '+' => Bitmap.PUNC_ADD,
            ',' => Bitmap.PUNC_COMMA,
            '-' => Bitmap.PUNC_DASH,
            '.' => Bitmap.PUNC_PERIOD,
            '/' => Bitmap.PUNC_FORWARD_SLASH,
            ':' => Bitmap.PUNC_COLON,
            ';' => Bitmap.PUNC_SEMICOLON,
            '<' => Bitmap.PUNC_LESS_THAN,
            '=' => Bitmap.PUNC_EQUALS,
            '>' => Bitmap.PUNC_GREATER_THAN,
            '?' => Bitmap.PUNC_QUESTION,
            '@' => Bitmap.PUNC_AT,
            '[' => Bitmap.PUNC_LEFT_SQUARE_BRACE,
            '\\' => Bitmap.PUNC_BACK_SLASH,
            ']' => Bitmap.PUNC_RIGHT_SQUARE_BRACE,
            '^' => Bitmap.PUNC_CARET,
            '_' => Bitmap.PUNC_UNDERSCORE,
            '`' => Bitmap.PUNC_BACKTICK,
            '{' => Bitmap.PUNC_LEFT_CURLY_BRACE,
            '|' => Bitmap.PUNC_PIPE,
            '}' => Bitmap.PUNC_RIGHT_CULRY_BRACE,
            '~' => Bitmap.PUNC_TILDE,
            '\n' | ' ' | '\t' | '\0' => Bitmap.SPACE,
            _ => Bitmap.ERROR
        }
    }

    def empty(): Bitmap {
        return { pixels = [[False] * BITMAP_WIDTH] * BITMAP_HEIGHT };
    }

    def width(self: &Bitmap): Int {
        return BITMAP_WIDTH;
    }

    def height(self: &Bitmap): Int {
        return BITMAP_HEIGHT;
    }

    def print(self: &Bitmap) {
        for let mut y=0; y < self.height(); y+=1 {
            for let mut x=0; x < self.width(); x+=1 {
                if self.pixels[y][x] {
                    print("*");
                } else {
                    print(" ");
                }
            }
            print("\n");
        }
    }

    def print_bordered(self: &Bitmap) {
        print("+");
        for let mut x=0; x < self.width(); x+=1 {
            print("-");
        }
        println("+");

        for let mut y=0; y < self.height(); y+=1 {
            print("|");
            for let mut x=0; x < self.width(); x+=1 {
                if self.pixels[y][x] {
                    print("*");
                } else {
                    print(" ");
                }
            }
            println("|");
        }

        print("+");
        for let mut x=0; x < self.width(); x+=1 {
            print("-");
        }
        println("+");
    }
}

type Pixel = (Int, Int, Int, Int);

struct Color {
    r: Int,
    g: Int,
    b: Int,
    a: Int
}

impl Color {
    const WHITE = { r = 255, g = 255, b = 255, a = 255 };
    const BLACK = { r = 0, g = 0, b = 0, a = 255 };
    const RED = { r = 255, g = 0, b = 0, a = 255 };
    const GREEN = { r = 0, g = 255, b = 0, a = 255 };
    const BLUE = { r = 0, g = 0, b = 255, a = 255 };
    const YELLOW = { r = 255, g = 255, b = 0, a = 255 };
    const CYAN = { r = 0, g = 255, b = 255, a = 255 };
    const MAGENTA = { r = 255, g = 0, b = 255, a = 255 };
    const TRANSPARENT = { r = 0, g = 0, b = 0, a = 0 };

    def from_rgb(r: Int, g: Int, b: Int): Color {
        return { r = r, g = g, b = b, a = 255 };
    }

    def from_rgb_f(r: Float, g: Float, b: Float): Color {
        // println("r = ", r);
        // println("g = ", g);
        // println("b = ", b);
        return { r = (r * 255) as Int, g = (g * 255) as Int, b = (b * 255) as Int, a = 255 };
    }

    def to_pixel(self: Color): Pixel {
        return (self.r, self.g, self.b, self.a);
    }

    def from_pixel(pixel: Pixel): Color {
        return { r = pixel.0, g = pixel.1, b = pixel.2, a = pixel.3 };
    }

    def to_float(self: &Color): (Float, Float, Float) {
        return ((self.r as Float) / 255.0, (self.g as Float) / 255.0, (self.b as Float) / 255.0);
    }

    // Create a color from hue, saturation, and value.
    def from_hsv(mut h: Float, s: Float, v: Float): Color {
        if s > 0.0 {
            if h > 0.99999 {
                h = 0.0;
            }
            let i = (h * 6.0) as Int;
            let f = (h * 6.0) - i;
            let w = (255 * v * (1.0 - s)) as Int;
            let q = (255 * v * (1.0 - s * f)) as Int;
            let t = (255 * v * (1.0 - s * (1.0 - f))) as Int;
            let v = (255 * v) as Int;

            if i == 0 {
                return { r = v, g = t, b = w, a = 255 };
            } elif i == 1 {
                return { r = q, g = v, b = w, a = 255 };
            } elif i == 2 {
                return { r = w, g = v, b = t, a = 255 };
            } elif i == 3 {
                return { r = w, g = q, b = v, a = 255 };
            } elif i == 4 {
                return { r = t, g = w, b = v, a = 255 };
            } else {
                return { r = v, g = w, b = q, a = 255 };
            }
        } else {
            Color.from_rgb_f(v, v, v);
        }
    }
}


let c = Color.from_hsv(359/360.0, 1.0, 1.0);
// println(c.to_float());











// A rectangle has an `x` and `y` position, a `width`, and a `height`.
struct Rectangle {
    x: Int,
    y: Int,
    width: Int,
    height: Int
}

impl Rectangle {
    def make(x: Int, y: Int, width: Int, height: Int): Rectangle {
        return { x = x, y = y, width = width, height = height };
    }

    // Calculate the area of a rectangle.
    def area(self: &Rectangle): Int {
        return self.width * self.height;
    }

    // Calculate the perimeter of a rectangle.
    def perimeter(self: &Rectangle): Int {
        return 2 * (self.width + self.height);
    }
}

// A type for representing the dimensions of a 2D shape.
struct Size {
    width: Int,
    height: Int
}

impl Size {
    def make(width: Int, height: Int): Size {
        return { width = width, height = height };
    }
}

// A type for representing the position of a 2D shape.
struct Position {
    x: Int,
    y: Int
}

impl Position {
    def make(x: Int, y: Int): Position {
        return { x = x, y = y };
    }
}



struct Mouse {
    x: Int,
    y: Int,
    left: Bool,
    right: Bool
}

impl Mouse {
    def make(x: Int, y: Int, left: Bool, right: Bool): Mouse {
        return { x = x, y = y, left = left, right = right };
    }

    def get_x(self: &Mouse): Int {
        return self.x;
    }

    def get_y(self: &Mouse): Int {
        return self.y;
    }

    def get_left(self: &Mouse): Bool {
        return self.left;
    }

    def get_right(self: &Mouse): Bool {
        return self.right;
    }

    def read(self: &mut Mouse, screen: &Screen) {
        when IS_RISCV {
            let (screen_width, screen_height) = (screen.width(), screen.height());
            match Event.read_tablet() {
                of Some(event) => {
                    if (event.get_type() == 1) {
                        self.left = event.get_value() == 272;
                        self.right = event.get_value() == 273;
                    } else {
                        let code = event.get_code();
                        let value = event.get_value();
                        if code == 0 {
                            self.x = value * screen_width / 0x7FFF;
                        } elif code == 1 {
                            self.y = value * screen_height / 0x7FFF;
                        } elif code == 2 {
                            self.left = value == 1;
                        } elif code == 3 {
                            self.right = value == 1;
                        }
                    }
                },
                _ => {
                    // println("Error: read() called but no mouse event was available.");
                }
            }
        } else {
            println("[Warning] Using Mouse.read on a non-RISC-V platform.");
            return ();
        }
    }
}


def min(x: Int, y: Int): Int {
    if x < y {
        return x;
    } else {
        return y;
    }
}

def max(x: Int, y: Int): Int {
    if x > y {
        return x;
    } else {
        return y;
    }
}

struct Keyboard {
    buf: &mut Char,
    cursor: Int,
    len: Int,
    capacity: Int,
    changed_since_last_read: Bool
}

impl Keyboard {
    def make(): Keyboard {
        return { buf = calloc<Char>(1024), cursor = 0, len = 0, capacity = 1024, changed_since_last_read = False };
    }

    def has_changed(self: &mut Keyboard): Bool {
        let result = self.changed_since_last_read;
        self.changed_since_last_read = False;
        return result;
    }

    def backspace(self: &mut Keyboard) {
        // Delete the character before the cursor.
        if self.cursor > 0 {
            self.changed_since_last_read = True;
            self.cursor -= 1;
            self.len -= 1;
            for let mut i = self.cursor; i < self.len; i += 1 {
                self.buf[i] = self.buf[i + 1];
            }
            self.buf[self.len] = '\0';
        }
    }

    def push(self: &mut Keyboard, c: Char) {
        // Push a character onto the end of the buffer.
        if self.len < self.capacity {
            self.changed_since_last_read = True;
            self.buf[self.len] = c;
            self.len += 1;
            self.cursor += 1;
        }
    }

    def read(self: &mut Keyboard) {
        when IS_RISCV {
            match Event.read_keyboard() {
                of Some(event) => {
                    println("Keyboard event: ", event);
                    if event.get_value() == 0 {
                        // Ignore key releases.
                        return ();
                    }
                    let key = event.get_key();
    
                    if key == '\b' {
                        // println("Backspace");
                        self.backspace();
                    } elif key == '\0' {
                        // Try to get the arrow keys.
                        let code = event.get_code();
                        if code == 106 {
                            // println("Right arrow");
                            // Right arrow.
                            self.cursor += 1;
                        } elif  code == 105 {
                            // println("Left arrow");
                            // Left arrow.
                            self.cursor -= 1;
                        } else {
                            // println("Unknown key code: ", code);
                        }
                    } else {
                        // println("Key: ", key);
                        self.push(key);
                    }
                },
                _ => {
                    // println("Error: read() called but no keyboard event was available.");
                }
            }
        } else {
            // println("[Warning] Using Keyboard.read on a non-RISC-V platform.");
            let mut ch = '\0';
            input(&mut ch);
            if ch != '\0' {
                self.push(ch);
            }
        }

        self.len = min(self.len, self.capacity);
        self.len = max(self.len, 0);
        self.cursor = min(self.cursor, self.len);
        self.cursor = max(self.cursor, 0);
    }

    def clear(self: &mut Keyboard) {
        self.changed_since_last_read = True;
        for let mut i=0; i<self.capacity; i+=1 {
            self.buf[i] = '\0';
        }
        self.cursor = 0;
        self.len = 0;
    }

    def read_line(self: &mut Keyboard): Option<&Char> {
        self.read();
        if self.len <= 0 {
            // println("Buf: ", self.buf);
            // println("No line to read (len <= 0). (self=", *self, ")");
            return Option<&Char> of Nothing;
        }

        if self.buf[self.len - 1] == '\n' {
            // println("Read line: ", self.buf);
            return Option<&Char> of Some(self.buf);
        } else {
            // println("Buf: ", self.buf);
            // println("No line to read. (self=", *self, ")");
            return Option<&Char> of Nothing;
        }
    }

    def drop(self: &mut Keyboard) {
        free(self.buf);
    }
}


def memcopy<T>(dst: &mut T, src: &T, elems: Int) {
    let size = elems * sizeof<T>();
    let dst_ptr = dst as &mut Cell;
    let src_ptr = src as &Cell;
    when IS_RISCV {
        // Do a memcopy using the RISC-V assembly instruction.
        extern memcpy(dst: &mut Cell, src: &Cell, size: Int);
        memcpy(dst_ptr, src_ptr, size);
    } else {
        for let mut i=0; i<size; i+=1 {
            dst_ptr[i] = src_ptr[i];
        }
    }
}

def calloc<T>(elems: Int): &mut T {
    println("Allocating ", elems, " elements of size ", sizeof<T>(), " cells.");
    extern used_memory(): Int;
    extern remaining_memory(): Int;
    // println("Used memory: ", used_memory());
    // println("Remaining memory: ", remaining_memory());

    let size = elems * sizeof<T>();
    let result = alloc(size) as &mut T;
    let cell_ptr = result as &mut Cell;
    for let mut i=0; i<size; i+=1 {
        cell_ptr[i] = 0;
    }
    return result;
}

def realloc<T>(ptr: &mut T, elems: Int): &mut T {
    // Reallocate the given pointer to the given number of elements.
    println("Reallocating ", elems, " elements of size ", sizeof<T>(), " cells.");
    extern used_memory(): Int;
    extern remaining_memory(): Int;

    let result = calloc<T>(elems);
    memcopy<T>(result, ptr, elems);
    free(ptr);
    return result;
}

struct Screen {
    x_scale: Int,
    y_scale: Int,
    rectangle: Rectangle,
    pixels: &mut Pixel,
    mouse: Mouse,
    keyboard: Keyboard,
    has_changed: Bool,
    has_flushed: Bool
}

impl Screen {
    def make(mut rectangle: Rectangle, x_scale: Int, y_scale: Int): Screen {
        rectangle.width /= x_scale;
        rectangle.height /= y_scale;
        let pixels = calloc<Pixel>(rectangle.area());
        return { rectangle = rectangle, pixels = pixels, x_scale = x_scale, y_scale = y_scale, mouse = Mouse.make(0, 0, False, False), keyboard = Keyboard.make(), has_changed = True, has_flushed = False };
    }

    def make_fullscreen(x_scale: Int, y_scale: Int): Screen {
        extern screen_get_dims(): (Int, Int);
        let (width, height) = screen_get_dims();
        let rectangle = Rectangle.make(0, 0, width, height);
        return Screen.make(rectangle, x_scale, y_scale);
    }
    
    def get_mouse(self: &Screen): Mouse {
        return self.mouse;
    }

    def read_inputs(self: &mut Screen) {
        self.mouse.read(self);
        self.keyboard.read();
    }

    def get_mouse_pos(self: &Screen): (Int, Int) {
        return (min(max(self.mouse.x / self.x_scale, 0), self.width()),
                min(max(self.mouse.y / self.y_scale, 0), self.height()));
    }

    def read_line(self: &mut Screen, dst: &mut Char): Bool {
        match self.keyboard.read_line() {
            of Some(line) => {
                for let mut i=0; line[i] != '\0' && i < self.keyboard.len; i+=1 {
                    dst[i] = line[i];
                }
                dst[self.keyboard.len] = '\0';
                self.keyboard.clear();
                return True;
            },
            _ => {
                return False;
            }
        }
    }

    def write_str(self: &mut Screen, text: &Char, color: Color, bg: Color, base_x: Int, base_y: Int): (Int, Int) {
        let mut x = base_x;
        let mut y = base_y;
        let mut c = '\0';
        for let mut i=0; text[i] != '\0' && y <= self.height(); i+=1 {
            c = text[i];

            if c == '\n' {
                y += Bitmap.HEIGHT;
                x = base_x;
            } elif c == '\r' {
                x = base_x;
            } else {
                let bitmap = Bitmap.from_char(c);
                self.set_bitmap(&bitmap, x, y, color, bg);
                x += bitmap.width();
            }
            
            if (x >= self.width()) {
                x = base_x;
                y += Bitmap.HEIGHT;
            }
        }
        return (x, y);
    }

    def width(self: &Screen): Int {
        return self.rectangle.width;
    }

    def height(self: &Screen): Int {
        return self.rectangle.height;
    }

    def area(self: &Screen): Int {
        return self.rectangle.area();
    }

    def set(self: &mut Screen, x: Int, y: Int, color: Color) {
        if x * y > self.area() {
            println("Error: set() called with out of bounds coordinates.");
            return ();
        }
        
        let i = y * self.width() + x;
        let p = color.to_pixel();
        let old_p = &(self.pixels[i]);
        if p.0 != old_p.0 || p.1 != old_p.1 || p.2 != old_p.2 || p.3 != old_p.3 {
            self.has_changed = True;
            self.pixels[i] = p;
        }
    }

    def get(self: &Screen, x: Int, y: Int): Pixel {
        if x * y > self.area() {
            println("Error: get() called with out of bounds coordinates.");
            return Color.from_rgb(0, 0, 0).to_pixel();
        }
        let i = y * self.width() + x;
        return self.pixels[i];
    }

    def draw(self: &mut Screen) {
        // println("Drawing...");
        self.draw_some(self.rectangle);
    }

    def draw_some(self: &mut Screen, rect: Rectangle) {
        // println("Drawing...");
        when IS_RISCV {
            if self.has_changed {
                extern screen_draw_rect(pixels: &mut Pixel, rect: &(Int, Int, Int, Int), x_scale: Int, y_scale: Int): Int;
                let tup = (rect.x * self.x_scale, rect.y * self.y_scale, rect.width, rect.height);
                println("Drawing rect: ", tup);
                let result = screen_draw_rect(self.pixels, &tup, self.x_scale, self.y_scale);
                if result != 0 {
                    println("Error: screen_draw_rect failed with code ", result);
                }
                self.has_flushed = False;
            } else {
                println("No changes to draw.");
            }
        }
    }

    def flush(self: &mut Screen) {
        self.flush_some(self.rectangle);
    }

    def flush_some(self: &mut Screen, rect: Rectangle) {
        // println("Flushing...");
        when IS_RISCV {
            if !(self.has_flushed) || self.has_changed {
                extern screen_flush(rect: &(Int, Int, Int, Int));
                let tup = (rect.x * self.x_scale, rect.y  * self.y_scale, rect.width * self.x_scale, rect.height * self.y_scale);
                println("Flushing rect: ", tup);
                screen_flush(&tup);
                self.has_flushed = True;
                self.has_changed = False;
            }
        } else {
            self.print();
        }
    }

    def set_bitmap(self: &mut Screen, bitmap: &Bitmap, x: Int, y: Int, color: Color, background: Color) {
        for let mut row = 0; row < bitmap.height(); row += 1 {
            for let mut col = 0; col < bitmap.width(); col += 1 {
                if bitmap.pixels[row][col] {
                    self.set(x + col, y + row, color);
                } else {
                    self.set(x + col, y + row, background);
                }
            }
        }
    }

    // def draw_bitmap(self: &Screen, bitmap: &Bitmap, x: Int, y: Int, color: Color) {
    //     println("Drawing bitmap...");
    //     let mut new_screen = Screen.make({ x = x, y = y, width = bitmap.width(), height = bitmap.height() }, self.x_scale, self.y_scale);
    //     new_screen.set_bitmap(bitmap, x, y, color);
    //     new_screen.draw();
    //     new_screen.drop();
    //     // extern screen_draw_bitmap(pixels: &mut Pixel, bitmap: &Bitmap, x: Int, y: Int): Int;
    //     // let result = screen_draw_bitmap(self.pixels, bitmap, x, y);
    //     // if result != 0 {
    //     //     println("Error: screen_draw_bitmap failed with code ", result);
    //     // }
    // }

    def print(self: &Screen) {
        if self.has_changed {
            // println("Printing...");
            // for let mut row = 0; row < self.height(); row += 1 {
            //     for let mut col = 0; col < self.width(); col += 1 {
            //         let i = row * self.width() + col;
            //         let (r, g, b, a) = self.pixels[i];
            //         print("(", r, ", ", g, ", ", b, ", ", a, ") ");
            //     }
            //     println("");
            // }
            let ESC = 0x1b as Char;

            for let mut row = 0; row < self.height(); row += 1 {
                for let mut col = 0; col < self.width(); col += 1 {

                    // Move the cursor to the correct position.
                    print(ESC, "[", row, ";", col, "H");

                    // Print the pixel.
                    let i = row * self.width() + col;
                    let (r, g, b, a) = self.pixels[i];
                    // println(pixel);
                    // let  = self.pixels[i];
                    print(ESC, "[48;2;", r, ";", g, ";", b, "m ");
                    // print(ESC, "[48;2;", self.pixels[i].r, ";", self.pixels[i].g, ";", self.pixels[i].b, "m ");
                }
            }

            // Move cursor to bottom left
            print(ESC, "[", self.height(), ";0H");
        } else {
            println("No changes to print.");
        }
    }

    def drop(self: &mut Screen) {
        self.keyboard.drop();
        free(self.pixels);
    }

    def clear(self: &mut Screen, color: Color) {
        for let mut row = 0; row < self.height(); row += 1 {
            for let mut col = 0; col < self.width(); col += 1 {
                self.set(col, row, color);
            }
        }
    }

    def clear_some(self: &mut Screen, rect: Rectangle, color: Color) {
        for let mut row = rect.y; row < rect.y + rect.height; row += 1 {
            for let mut col = rect.x; col < rect.x + rect.width; col += 1 {
                self.set(col, row, color);
            }
        }
    }
}

type Event = (Int, Int, Int);
let static mut KEYBOARD_SHIFT: Bool = False;

impl Event {
    def read_keyboard(): Option<Event> {
        extern get_keyboard_event(): Event;
        let event = get_keyboard_event();

        if event.get_type() == 1 {
            return Option<Event> of Some(event);
        } else {
            // println("Error: read_keyboard() called but no keyboard event was available (event=", event, ").");
            return Option<Event> of Nothing;
        }
    }

    def read_tablet(): Option<Event> {
        extern get_table_event(): Event;
        let event = get_table_event();
        if event.get_type() == 1 && (event.get_code() == 272 || event.get_code() == 273) {
            return Option<Event> of Some(event);
        } elif event.get_type() == 3 {
            return Option<Event> of Some(event);
        } else {
            // println("Error: read_tablet() called but no tablet event was available (event=", event, ").");
            return Option<Event> of Nothing;
        }
    }

    def get_type(self: &Event): Int {
        return self.0;
    }

    def get_code(self: &Event): Int {
        return self.1;
    }

    def get_value(self: &Event): Int {
        return self.2;
    }

    const KEYS = {
        A=30,
        B=48,
        C=46,
        D=32,
        E=18,
        F=33,
        G=34,
        H=35,
        I=23,
        J=36,
        K=37,
        L=38,
        M=50,
        N=49,
        O=24,
        P=25,
        Q=16,
        R=19,
        S=31,
        T=20,
        U=22,
        V=47,
        W=17,
        X=45,
        Y=21,
        Z=44,
        ESC=1,
        BACKSPACE=14,
        ENTER=28,
        NUM_0=11,
        NUM_1=2,
        NUM_2=3,
        NUM_3=4,
        NUM_4=5,
        NUM_5=6,
        NUM_6=7,
        NUM_7=8,
        NUM_8=9,
        NUM_9=10,
        SPACE=57,
        SLASH=53,
        PERIOD=52
    };

    const NUM_SHIFT_KEYS = [
        ')',
        '!',
        '@',
        '#',
        '$',
        '%',
        '^',
        '&',
        '*',
        '('
    ];

    def num_keys(): Int {
        return sizeof(Event.KEYS) / sizeof(Event.KEYS.A);
    }

    def get_key(self: &Event): Char {
        // static char conv_key(int code)
        // {
        //     char ret = 0;

        //     if (code < num_keys)
        //     {
        //         ret = keys[code];
        //         if (shift) 
        //         {
        //             if (ret >= 'a' && ret <= 'z')
        //             {
        //                 ret -= 32;
        //             }
        //             else if (ret >= '0' && ret <= '9')
        //             {
        //                 ret = num_shift_keys[ret - '0'];
        //             }
        //         }
        //     }

        //     return ret;
        // }
        def code_to_key(code: Int): Char {
            let mut ret = '\0';
            
            ret = match code {
                (Event.KEYS.A) => 'a',
                (Event.KEYS.B) => 'b',
                (Event.KEYS.C) => 'c',
                (Event.KEYS.D) => 'd',
                (Event.KEYS.E) => 'e',
                (Event.KEYS.F) => 'f',
                (Event.KEYS.G) => 'g',
                (Event.KEYS.H) => 'h',
                (Event.KEYS.I) => 'i',
                (Event.KEYS.J) => 'j',
                (Event.KEYS.K) => 'k',
                (Event.KEYS.L) => 'l',
                (Event.KEYS.M) => 'm',
                (Event.KEYS.N) => 'n',
                (Event.KEYS.O) => 'o',
                (Event.KEYS.P) => 'p',
                (Event.KEYS.Q) => 'q',
                (Event.KEYS.R) => 'r',
                (Event.KEYS.S) => 's',
                (Event.KEYS.T) => 't',
                (Event.KEYS.U) => 'u',
                (Event.KEYS.V) => 'v',
                (Event.KEYS.W) => 'w',
                (Event.KEYS.X) => 'x',
                (Event.KEYS.Y) => 'y',
                (Event.KEYS.Z) => 'z',
                (Event.KEYS.NUM_0) => '0',
                (Event.KEYS.NUM_1) => '1',
                (Event.KEYS.NUM_2) => '2',
                (Event.KEYS.NUM_3) => '3',
                (Event.KEYS.NUM_4) => '4',
                (Event.KEYS.NUM_5) => '5',
                (Event.KEYS.NUM_6) => '6',
                (Event.KEYS.NUM_7) => '7',
                (Event.KEYS.NUM_8) => '8',
                (Event.KEYS.NUM_9) => '9',
                (Event.KEYS.BACKSPACE) => '\b',
                (Event.KEYS.ENTER) => '\n',
                (Event.KEYS.ESC) => '~',
                (Event.KEYS.SPACE) => ' ',
                (Event.KEYS.SLASH) => '/',
                (Event.KEYS.PERIOD) => '.',

                _ => {
                    println("Error: code_to_key() called with invalid code ", code);
                    return '\0';
                }
            };

            println("ret = ", ret);

            if KEYBOARD_SHIFT {
                println("Shift is down.");
                if ret as Int >= 'a' as Int && ret as Int <= 'z' as Int {
                    println("Converting to uppercase.");
                    ret = (ret as Int - 32) as Char;
                    println("ret = ", ret);
                } elif ret as Int >= '0' as Int && ret as Int <= '9' as Int {
                    let num_shift_keys = Event.NUM_SHIFT_KEYS;
                    println("Converting to shifted number.");
                    ret = num_shift_keys[ret as Int - '0' as Int];
                    println("ret = ", ret);
                }
            }
            return ret;
        }

        return code_to_key(self.get_code());
    }

    def print(self: &Event) {
        let ty = self.get_type();
        let code = self.get_code();
        let value = self.get_value();
        println("Event: type=", ty, ", code=", code, ", value=", value);
    }
}

def count_lines(s: &Char): Int {
    let mut count = 0;
    for let mut i=0; s[i] != '\0'; i+=1 {
        if s[i] == '\n' {
            count += 1;
        }
    }
    return count;
}

def strlen(s: &Char): Int {
    when IS_RISCV {
        extern strlen(s: &Char): Int;
        return strlen(s);
    } else {
        let mut i = 0;
        for (); s[i] != '\0'; i += 1 {}
        return i;
    }
}

def strcomp(s1: &Char, s2: &Char): Int {
    when IS_RISCV {
        extern strcmp(s1: &Char, s2: &Char, len: Int): Int;
        let len = max(strlen(s1), strlen(s2));
        return strcmp(s1, s2, len);
    } else {
        let mut i = 0;
        for (); s1[i] != '\0' && s2[i] != '\0' && s1[i] == s2[i]; i += 1 {}
        return s1[i] as Int - s2[i] as Int;
    }
}

type Symbol = [Char * 64];

impl Symbol {
    def make(): Symbol {
        return ['\0'] * sizeof<Symbol>();
    }

    def is_empty(self: &Symbol): Bool {
        return self.len() == 0;
    }

    def eq(self: &Symbol, other: &Symbol): Bool {
        return strcomp(self.str(), other.str()) == 0;
    }

    def from_str(s: &Char): Symbol {
        let mut result = Symbol.make();
        let (mut i, mut j) = (0, 0);
        let mut last_was_slash = False;
        for (); i < sizeof<Symbol>() - 1 && s[i] != '\0'; i += 1 {
            if s[i] == ' ' || s[i] == '\n' || s[i] == '\r' || s[i] == '\t' {
                // Skip whitespace.
            } else {
                if last_was_slash && s[i] == '/' {
                    // Skip duplicate slashes.
                } else {
                    last_was_slash = s[i] == '/';
                    result[j] = s[i];
                    j += 1;
                }
            }
        }

        return result;
    }

    def begins_with(self: &Symbol, other: &Char): Bool {
        let str = self.str();
        for let mut i = 0; str[i] != '\0' && other[i] != '\0'; i += 1 {
            if str[i] != other[i] {
                return False;
            }
        }
        return True;
    }

    def remove_front(self: &mut Symbol, n: Int) {
        let mut i = 0;
        let str = self.str_mut();
        for (); i < sizeof<Symbol>() - 1 && str[i] != '\0'; i += 1 {
            str[i] = str[i + n];
        }
        str[i] = '\0';
    }

    def str(self: &Symbol): &Char {
        return self as &Char;
    }
    
    def str_mut(self: &mut Symbol): &mut Char {
        return self as &mut Char;
    }

    def len(self: &Symbol): Int {
        return strlen(self.str());
    }

    def print(self: &Symbol) {
        print(self.str());
    }

    def println(self: &Symbol) {
        println(self.str());
    }
}

type Path = [Char * 128];

let mut root = ['\0'] * sizeof<Path>();
root[0] = '/';
let static ROOT: Path = root;

let mut home = ['\0'] * sizeof<Path>();
home[0] = '/';
home[1] = 'h';
home[2] = 'o';
home[3] = 'm';
home[4] = 'e';
home[5] = '\0';
let static HOME: Path = home;



impl Path {
    def make(): Path {
        return ['\0'] * sizeof<Path>();
    }

    def root(): &Path {
        return &ROOT;
    }

    def home(): &Path {
        return &HOME;
    }

    def str(self: &Path): &Char {
        return self as &Char;
    }

    def str_mut(self: &mut Path): &mut Char {
        return self as &mut Char;
    }

    def is_root(self: &Path): Bool {
        return self.str()[0] == '/' && self.str()[1] == '\0';
    }

    def is_home(self: &Path): Bool {
        return strcomp(self.str(), &"/home" as &Char) == 0;
    }

    def is_empty(self: &Path): Bool {
        return self.str()[0] == '\0';
    }

    def copy_from(self: &mut Path, other: &Path) {
        let str = self.str_mut();
        let mut i = 0;
        for (); i < sizeof<Path>() - 1 && other.str()[i] != '\0'; i += 1 {
            str[i] = other.str()[i];
        }
        str[i] = '\0';
    }

    def from_str(s: &Char): Path {
        let mut path = Path.make();
        path[0] = '/';
        let (mut i, mut j) = (1, 1);
        for (); i < sizeof<Path>() - 1 && s[i] != '\0'; i += 1 {
            // Skip duplicate slashes, whitespace, and trailing slashes.
            match s[i] {
                '/' => {
                    if j > 0 && path[j - 1] != '/' {
                        path[j] = s[i];
                        j += 1;
                    }
                },
                '\n' | '\r' | '\t'=> {
                    // Skip whitespace.
                },
                ' ' => {
                    if j > 0 && path[j - 1] != '/' {
                        path[j] = s[i];
                        j += 1;
                    }
                },
                _ => {
                    path[j] = s[i];
                    j += 1;
                }
            }
        }
        return path;
    }

    def get_name(self: &Path): &Char {
        if self.is_root() {
            return &"/";
        }

        let str = self.str();
        let mut i = 0;
        for let mut j = 0; str[j] != '\0'; j += 1 {
            if str[j] == '/' {
                i = j + 1;
            }
        }
        return &(str[i]);
    }

    def depth(self: &Path): Int {
        let mut depth = 0;
        let str = self.str();
        for let mut i = 0; str[i] != '\0'; i += 1 {
            if str[i] == '/' {
                depth += 1;
            }
        }
        return depth;
    }

    def len(self: &Path): Int {
        return strlen(self.str());
    }

    // def get_parent(self: &Path): Path {
    //     if self.is_root() || self.is_empty() {
    //         return Path.root();
    //     }

    //     let str = self.str();
    //     let mut i = 0;
    //     for let mut j = 0; str[j] != '\0'; j += 1 {
    //         if str[j] == '/' {
    //             i = j + 1;
    //         }
    //     }
    //     let mut parent_path = Path.make();
    //     for let mut j = 0; j < i; j += 1 {
    //         parent_path[j] = str[j];
    //     }
    //     parent_path[i] = '\0';
    //     return parent_path;
    // }

    def push(self: &mut Path, s: &mut Symbol) {
        println("Pushing ", s.str(), " onto ", self.str());
        if s.is_empty() {
            return ();
        }

        if strcomp(s.str(), &"." as &Char) == 0 {
            return ();
        } elif s.begins_with(&"./" as &Char) {
            s.remove_front(2);
            self.push(s);
            // self.push(Symbol.from_str(&(s.str()[2])));
            return ();
        } elif strcomp(s.str(), &".." as &Char) == 0 {
            // *self = self.get_parent();
            let _ = self.pop();
            return ();
        } elif s.begins_with(&"../" as &Char) {
            // *self = self.get_parent();
            let _ = self.pop();
            s.remove_front(3);
            self.push(s);
            // self.push(Symbol.from_str(&(s.str()[3])));
            return ();
        } elif strcomp(s.str(), &"/" as &Char) == 0 {
            // *self = Path.root();
            let str = self.str_mut();
            str[0] = '/';
            str[1] = '\0';
            return ();
        } elif s.begins_with(&"/" as &Char) {
            // *self = self.get_parent();
            // *self = Path.root();
            let str = self.str_mut();
            str[0] = '/';
            str[1] = '\0';
            s.remove_front(1);
            self.push(s);
            // self.push(Symbol.from_str(&(s.str()[3])));
            return ();
        } elif strcomp(s.str(), &"~" as &Char) == 0 {
            let str = self.str_mut();
            str[0] = '/';
            str[1] = 'h';
            str[2] = 'o';
            str[3] = 'm';
            str[4] = 'e';
            str[5] = '\0';
            return ();
        } elif s.begins_with(&"~/" as &Char) {
            let str = self.str_mut();
            str[0] = '/';
            str[1] = 'h';
            str[2] = 'o';
            str[3] = 'm';
            str[4] = 'e';
            str[5] = '\0';
            s.remove_front(2);
            self.push(s);
            // self.push(Symbol.from_str(&(s.str()[2])));
            return ();
        }

        let mut i = 0;
        let str = self.str_mut();
        // Add a slash if necessary.
        for i=0; str[i] != '\0'; i += 1 {}
        if i > 0 && str[i - 1] != '/' {
            str[i] = '/';
            i += 1;
        }
        println("i=", i);
        let src_str = s.str();
        let mut is_done = False;
        for let mut j = 0; j < sizeof<Symbol>() - 1 && src_str[j] != '\0' && !is_done; j += 1 {
            println("j=", j, ", s[j]=", src_str[j]);
            if src_str[j] == '/' {
                // Recursively push the rest of the path.
                s.remove_front(j + 1);
                str[i] = '\0';
                self.push(s);
                is_done = True;
            } else {
                str[i] = src_str[j];
                i += 1;
            }
        }
        if !is_done {
            str[i] = '\0';
        }
        // str[i + sizeof<Symbol>() - 1] = '\0';
    }

    def pop(self: &mut Path): Symbol {
        if self.is_root() || self.is_empty() {
            return Symbol.make();
        }

        let mut i = 0;
        let str = self.str_mut();
        for let mut j = 0; str[j] != '\0'; j += 1 {
            if str[j] == '/' {
                i = j + 1;
            }
        }
        let mut result = Symbol.make();
        for let mut j = 0; j < sizeof<Symbol>() - 1; j += 1 {
            result[j] = str[i + j];
        }
        result[sizeof<Symbol>() - 1] = '\0';
        for let mut j = i; j < sizeof<Path>() - 1; j += 1 {
            str[j] = '\0';
        }
        
        return result;
    }

    def print(self: &Path) {
        print(self.str());
    }

    def println(self: &Path) {
        println(self.str());
    }
}

type SmolString = [Char * 256];

impl SmolString {
    def make(): SmolString {
        return ['\0'] * sizeof<SmolString>();
    }
    
    def from_int(n: Int): SmolString {
        let mut result = SmolString.make();
        let mut i = 0;
        let mut j = 0;
        let mut digits = [0] * 64;
        if n < 0 {
            result[j] = '-';
            j += 1;
            i += 1;
        }
        let mut n = n;
        while n > 0 {
            digits[i] = n % 10;
            n /= 10;
            i += 1;
        }
        if i == 0 {
            digits[i] = 0;
            i += 1;
        }
        for (); i > 0; i -= 1 {
            result[j] = (digits[i - 1] as Int + '0' as Int) as Char;
            j += 1;
        }
        result[j] = '\0';
        return result;
    }
    
    def count_lines(self: &SmolString): Int {
        return count_lines(self.str());
    }

    def append(self: &mut SmolString, other: &SmolString) {
        self.push_str(other.str());
    }

    def push_str(self: &mut SmolString, s: &Char) {
        let len = self.len();
        let str = self.str_mut();
        let mut i = 0;
        for (); i + len < sizeof<SmolString>() - 1 && s[i] != '\0'; i += 1 {
            str[len + i] = s[i];
        }
        // Add a null terminator.
        str[len + i] = '\0';
    }

    def push_int(self: &mut SmolString, n: Int) {
        let s = SmolString.from_int(n);
        self.push_str(s.str());
    }

    def from_str(s: &Char): SmolString {
        let mut result = SmolString.make();
        for let mut i = 0; i < sizeof<SmolString>() - 1 && s[i] != '\0'; i += 1 {
            result[i] = s[i];
        }
        return result;
    }

    def nth_symbol(self: &SmolString, mut n: Int): Option<Symbol> {
        let mut i = 0;
        let mut j = 0;
        let mut result = Symbol.make();
        let str = self.str();
        for (); str[i] != '\0'; i += 1 {
            if str[i] == ' ' || str[i] == '\n' || str[i] == '\r' || str[i] == '\t' {
                // Skip whitespace.
                if j > 0 {
                    result[j] = '\0';
                    if n == 0 {
                        return Option<Symbol> of Some(result);
                    }
                    n -= 1;
                    j = 0;
                }
            } else {
                result[j] = str[i];
                j += 1;
            }
        }
        if j > 0 {
            result[j] = '\0';
            if n == 0 {
                return Option<Symbol> of Some(result);
            }
            n -= 1;
            j = 0;
        }
        return Option<Symbol> of Nothing;
    }

    def trim_start(self: &mut SmolString, pattern: &Char) {
        let mut i = 0;
        let mut j = 0;
        let mut result = SmolString.make();
        let str = self.str();
        for (); str[i] != '\0' && str[i] == pattern[i]; i += 1 {}
        for (); str[i] != '\0'; i += 1 {
            result[j] = str[i];
            j += 1;
        }

        result[j] = '\0';
        memcopy<SmolString>(self, &result, sizeof<SmolString>());
    }

    def trim_whitespace(self: &mut SmolString) {
        let mut i = 0;
        let str = self.str();
        for (); str[i] != '\0' && (str[i] == ' ' || str[i] == '\n' || str[i] == '\r' || str[i] == '\t'); i += 1 {}
        let mut j = 0;
        let mut result = SmolString.make();
        for (); str[i] != '\0'; i += 1 {
            result[j] = str[i];
            j += 1;
        }
        result[j] = '\0';
        memcopy<SmolString>(self, &result, sizeof<SmolString>());
    }

    def str(self: &SmolString): &Char {
        return self as &Char;
    }

    def str_mut(self: &mut SmolString): &mut Char {
        return self as &mut Char;
    }

    def len(self: &SmolString): Int {
        return strlen(self.str());
    }

    def print(self: &SmolString) {
        print(self.str());
    }

    def println(self: &SmolString) {
        println(self.str());
    }
}

enum FileMode {
    Read,
    Write,
    Append
}

struct OS {
    list_dir: (&mut Env, &Path) -> Result<(), Error>,
    spawn: (&mut Env, &Path) -> Result<Int, Error>,
    open: (&mut Env, &Path, FileMode) -> Result<&mut File, Error>,
    create_dir: (&mut Env, &Path) -> Result<(), Error>,
    is_dir: (&mut Env, &Path) -> Result<Bool, Error>,
    is_file: (&mut Env, &Path) -> Result<Bool, Error>,
    list_pid: (&mut Env) -> Result<(), Error>,
    list_mem: (&mut Env) -> Result<(), Error>,
    print_env: (&mut Env) -> Result<(), Error>,
    print_dir: (&mut Env) -> Result<(), Error>,
    change_dir: (&mut Env, &Path) -> Result<(), Error>,
    read: (&mut Env, &Path) -> Result<SmolString, Error>,
    write: (&mut Env, &Path) -> Result<(), Error>,
    append: (&mut Env, &Path) -> Result<(), Error>,
    close: (&mut Env, &mut File) -> Result<(), Error>,
    copy: (&mut Env, &Path, &Path) -> Result<(), Error>,
    remove: (&mut Env, &Path) -> Result<(), Error>,
    make_dir: (&mut Env, &Path) -> Result<(), Error>,
    help: (&mut Env, &Symbol) -> Result<(), Error>,
    exit: (&mut Env) -> Result<(), Error>
}

impl OS {
    def make(): OS {
        when IS_RISCV {
            def open(env: &mut Env, path: &Path, mode: FileMode): Result<&mut File, Error> {
                // println("Opening file ", path, "...");
                env.echo_colored(&"Opening ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<&mut File, Error> of Ok(new File.make(*path, FileMode of Read));
            }

            def spawn(env: &mut Env, path: &Path): Result<Int, Error> {
                // println("Changing directory to ", path, "...");
                env.echo_colored(&"Spawning ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                
                extern path_exists(path: &Char): Bool;
                if !(path_exists(path.str())) {
                    env.echo_coloredln(&"Path does not exist!", Color.RED);
                    return Result<Int, Error> of Err(Error of PathNotFound path);
                }

                extern spawn_process(path: &Char): Int;
                let pid = spawn_process(path.str());
                if pid < 0 {
                    env.echo_coloredln(&"Failed to spawn process!", Color.RED);
                    return Result<Int, Error> of Err(Error of ProcessSpawnFailed path);
                }

                return Result<Int, Error> of Ok(pid);
            }

            def create_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Creating directory ", path, "...");
                env.echo_colored(&"Creating ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def is_dir(env: &mut Env, path: &Path): Result<Bool, Error> {
                // println("Checking if ", path, " is a directory...");
                env.echo_colored(&"Checking if", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&" is dir...", Color.GREEN);

                extern path_is_dir(path: &Char): Bool;
                return Result<Bool, Error> of Ok(path_is_dir(path.str()));
            }

            def is_file(env: &mut Env, path: &Path): Result<Bool, Error> {
                // println("Checking if ", path, " is a file...");
                env.echo_colored(&"Checking if ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&" is file...", Color.GREEN);

                extern path_is_file(path: &Char): Bool;
                return Result<Bool, Error> of Ok(path_is_file(path.str()));
            }
            
            def list_dir(env: &mut Env, path: &Path): Result<(), Error> {
                env.echo_colored(&"Listing ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                
                extern path_list_dir(path: &Char, buf: &mut Char, buf_len: Int, use_full_path: Bool): Int;
                let mut buf = ['\0'] * 1024;

                let use_full_path = False;
                let ret = path_list_dir(path.str(), &mut buf as &mut Char, sizeof(buf), use_full_path);
                if (ret < 0) {
                    return Result<(), Error> of Err(Error of PathNotFound path);
                }

                env.echo_coloredln(&buf, Color.BLUE);

                // For every line in the buffer
                // for let mut i=0; buf[i] != '\0'; i+=1 {
                //     // For every character in the line
                //     let mut found_line = False;
                //     for let mut j=i; buf[j] != '\0' && !found_line; j+=1 {
                //         // If we find a newline
                //         if buf[j] == '\n' {
                //             buf[j] = '\0';
                //             env.echo_colored(&(buf[i]), Color.BLUE);
                //             env.echo_newline();
                //             buf[j] = '\n';
                //             // And break
                //             found_line = True;
                //         }
                //     }
                // }

                return Result<(), Error> of Ok(());
            }


            def list_pid(env: &mut Env): Result<(), Error> {
                // println("Listing PID...");
                env.echo_coloredln(&"Listing PID...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def list_mem(env: &mut Env): Result<(), Error> {
                // println("Listing memory...");
                env.echo_coloredln(&"Listing memory...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def print_env(env: &mut Env): Result<(), Error> {
                println("Printing environment...");
                env.echo_colored(&"Printing environment...", Color.GREEN);
                env.echo_newline();
                return Result<(), Error> of Ok(());
            }

            def print_dir(env: &mut Env): Result<(), Error> {
                println("Printing directory...");
                env.echo_colored(&"Printing directory...", Color.GREEN);
                env.echo_newline();
                return Result<(), Error> of Ok(());
            }

            def change_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Changing directory to ", path, "...");
                env.echo_colored(&"Changing directory to ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                extern path_exists(path: &Char): Bool;
                if !(path_exists(path.str())) {
                    env.echo_coloredln(&"Path does not exist!", Color.RED);
                    return Result<(), Error> of Err(Error of PathNotFound path);
                }

                return Result<(), Error> of Ok(());
            }

            def read(env: &mut Env, path: &Path): Result<SmolString, Error> {
                // println("Reading file ", path, "...");
                env.echo_colored(&"Reading file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<SmolString, Error> of Ok(SmolString.make());
            }

            def write(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Writing to file ", path, "...");
                env.echo_colored(&"Writing to file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def append(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Appending to file ", path, "...");
                env.echo_colored(&"Appending to file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def close(env: &mut Env, file: &mut File): Result<(), Error> {
                // println("Closing file ", path, "...");
                env.echo_colored(&"Closing file ", Color.GREEN);
                env.echo_colored(file.get_path().str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<(), Error> of Ok(());
            }

            def copy(env: &mut Env, src: &Path, dst: &Path): Result<(), Error> {
                // println("Copying file ", src, " to ", dst, "...");
                env.echo_colored(&"Copying file ", Color.GREEN);
                env.echo_colored(src.str(), Color.BLUE);
                env.echo_colored(&" to ", Color.GREEN);
                env.echo_colored(dst.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<(), Error> of Ok(());
            }

            def remove(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Removing file ", path, "...");
                env.echo_colored(&"Removing file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_colored(&"...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            def make_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Making directory ", path, "...");
                env.echo_colored(&"Making directory ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_colored(&"...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            def help(env: &mut Env, path: &Symbol): Result<(), Error> {
                // println("Helping...");
                env.echo_colored(&"Helping...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            def exit(env: &mut Env): Result<(), Error> {
                // println("Exiting...");
                env.echo_colored(&"Exiting...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            return {
                list_dir = list_dir,
                open = open,
                spawn = spawn,
                create_dir = create_dir,
                is_dir = is_dir,
                is_file = is_file,
                list_pid = list_pid,
                list_mem = list_mem,
                print_env = print_env,
                print_dir = print_dir,
                change_dir = change_dir,
                read = read,
                write = write,
                append = append,
                close = close,
                copy = copy,
                remove = remove,
                make_dir = make_dir,
                help = help,
                exit = exit
            };
        } else {
            def list_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Listing directory ", path, "...");
                env.echo_colored(&"Listing ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def spawn(env: &mut Env, path: &Path): Result<Int, Error> {
                env.echo_colored(&"Spawning ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<Int, Error> of Ok(0);
            }

            def open(env: &mut Env, path: &Path, mode: FileMode): Result<&mut File, Error> {
                // println("Opening file ", path, "...");
                env.echo_colored(&"Opening ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<&mut File, Error> of Ok(new File.make(*path, FileMode of Read));
            }

            def create_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Creating directory ", path, "...");
                env.echo_colored(&"Creating ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def is_dir(env: &mut Env, path: &Path): Result<Bool, Error> {
                // println("Checking if ", path, " is a directory...");
                env.echo_colored(&"Checking if", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&" is dir...", Color.GREEN);

                return Result<Bool, Error> of Ok(False);
            }

            def is_file(env: &mut Env, path: &Path): Result<Bool, Error> {
                // println("Checking if ", path, " is a file...");
                env.echo_colored(&"Checking if ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&" is file...", Color.GREEN);

                return Result<Bool, Error> of Ok(True);
            }

            def list_pid(env: &mut Env): Result<(), Error> {
                // println("Listing PID...");
                env.echo_coloredln(&"Listing PID...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def list_mem(env: &mut Env): Result<(), Error> {
                // println("Listing memory...");
                env.echo_coloredln(&"Listing memory...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def print_env(env: &mut Env): Result<(), Error> {
                println("Printing environment...");
                env.echo_colored(&"Printing environment...", Color.GREEN);
                env.echo_newline();
                return Result<(), Error> of Ok(());
            }

            def print_dir(env: &mut Env): Result<(), Error> {
                println("Printing directory...");
                env.echo_colored(&"Printing directory...", Color.GREEN);
                env.echo_newline();
                return Result<(), Error> of Ok(());
            }

            def change_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Changing directory to ", path, "...");
                env.echo_colored(&"Changing directory to ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<(), Error> of Ok(());
            }

            def read(env: &mut Env, path: &Path): Result<SmolString, Error> {
                // println("Reading file ", path, "...");
                env.echo_colored(&"Reading file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<SmolString, Error> of Ok(SmolString.make());
            }

            def write(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Writing to file ", path, "...");
                env.echo_colored(&"Writing to file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def append(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Appending to file ", path, "...");
                env.echo_colored(&"Appending to file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);
                return Result<(), Error> of Ok(());
            }

            def close(env: &mut Env, path: &mut File): Result<(), Error> {
                // println("Closing file ", path, "...");
                env.echo_colored(&"Closing file ", Color.GREEN);
                env.echo_colored(path.get_path().str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<(), Error> of Ok(());
            }

            def copy(env: &mut Env, src: &Path, dst: &Path): Result<(), Error> {
                // println("Copying file ", src, " to ", dst, "...");
                env.echo_colored(&"Copying file ", Color.GREEN);
                env.echo_colored(src.str(), Color.BLUE);
                env.echo_colored(&" to ", Color.GREEN);
                env.echo_colored(dst.str(), Color.BLUE);
                env.echo_coloredln(&"...", Color.GREEN);

                return Result<(), Error> of Ok(());
            }

            def remove(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Removing file ", path, "...");
                env.echo_colored(&"Removing file ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_colored(&"...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            def make_dir(env: &mut Env, path: &Path): Result<(), Error> {
                // println("Making directory ", path, "...");
                env.echo_colored(&"Making directory ", Color.GREEN);
                env.echo_colored(path.str(), Color.BLUE);
                env.echo_colored(&"...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            def help(env: &mut Env, path: &Symbol): Result<(), Error> {
                // println("Helping...");
                env.echo_colored(&"Helping...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            def exit(env: &mut Env): Result<(), Error> {
                // println("Exiting...");
                env.echo_colored(&"Exiting...", Color.GREEN);
                env.echo_newline();

                return Result<(), Error> of Ok(());
            }

            return {
                list_dir = list_dir,
                spawn = spawn,
                open = open,
                create_dir = create_dir,
                is_dir = is_dir,
                is_file = is_file,
                list_pid = list_pid,
                list_mem = list_mem,
                print_env = print_env,
                print_dir = print_dir,
                change_dir = change_dir,
                read = read,
                write = write,
                append = append,
                close = close,
                copy = copy,
                remove = remove,
                make_dir = make_dir,
                help = help,
                exit = exit
            };
        }
    }
}

struct File {
    path: Path,
    mode: FileMode
}


impl File {
    def make(path: Path, mode: FileMode): File {
        return { path = path, mode = mode };
    }

    def open(path: &Path, mode: FileMode, env: &mut Env): Result<&mut File, Error> {
        return env.get_os().open(env, path, mode);
    }

    def create_dir(path: &Path, env: &mut Env): Result<(), Error> {
        return env.get_os().create_dir(env, path);
    }

    def list_dir(path: &Path, env: &mut Env): Result<(), Error> {
        return env.get_os().list_dir(env, path);
    }

    def is_dir(self: &File, env: &mut Env): Bool {
        return env.get_os().is_dir(env, &(self.path)).unwrap_or(False);
    }

    def is_file(self: &File, env: &mut Env): Bool {
        return env.get_os().is_file(env, &(self.path)).unwrap_or(False);
    }

    def get_path(self: &File): &Path {
        return &(self.path);
    }

    def get_name(self: &File): &Char {
        return self.path.get_name();
    }

    // def get_parent(self: &File): Path {
    //     return self.path.get_parent();
    // }

    def write(self: &File, text: &Char, env: &mut Env): Result<(), Error> {
        return env.get_os().write(env, &(self.path));
    }

    def read(self: &File, env: &mut Env): Result<SmolString, Error> {
        return env.get_os().read(env, &(self.path));
    }

    def close(self: &mut File, env: &mut Env): Result<(), Error> {
        return env.get_os().close(env, self);
    }
}


enum Command {
    Read(Symbol),
    Write(Symbol, SmolString),
    Append(Symbol, SmolString),
    Copy(Symbol, Symbol),
    MakeDir(Symbol),
    ChangeDir(Symbol),
    Spawn(Symbol),
    PrintDir,
    ListDir,
    ListPID,
    ListMem,
    Help(Symbol),
    PrintEnv,
    Invalid(SmolString)
}

struct History {
    commands: &mut Command,
    length: Int,
    capacity: Int
}

impl History {
    def make(): History {
        return { commands = calloc<Command>(8), length = 0, capacity = 8 };
    }

    def push(self: &mut History, command: Command) {
        if self.length >= self.capacity {
            // Grow the array.
            self.capacity *= 2;
            self.commands = realloc<Command>(self.commands, self.capacity);
        }
        self.commands[self.length] = command;
        self.length += 1;
        if self.length >= self.capacity {
            // Grow the array.
            self.capacity *= 2;
            self.commands = realloc<Command>(self.commands, self.capacity);
        }
    }

    def len(self: &History): Int {
        return self.length;
    }

    def get(self: &History, index: Int): Option<&Command> {
        if index < 0 || index >= self.length {
            return Option<&Command> of Nothing;
        }
        return Option<&Command> of Some(&(self.commands[index]));
    }

    def drop(self: &mut History) {
        free(self.commands);
    }

    def print(self: &History) {
        for let mut i = 0; i < self.length; i += 1 {
            print(i, ": ");
            self.commands[i].println();
        }
    }

    def echo(self: &History, env: &mut Env) {
        for let mut i = 0; i < self.length; i += 1 {
            let s = SmolString.from_int(i);
            // print(i, ": ");
            env.echo(s.str());
            env.echo(&": " as &Char);
            self.commands[i].echo(env);
        }
    }
}

struct Env {
    os: OS,
    cwd: Path,
    history: History,
    screen: Screen,

    prompt_row: Int,
    prompt_col: Int,

    echo_row: Int,
    echo_col: Int
}

impl Env {
    def make(mut screen: Screen): Env {
        screen.clear(Color.BLACK);
        screen.flush();
        return { cwd = *(Path.home()), history = History.make(), os = OS.make(), screen = screen, echo_row = 0, echo_col = 0, prompt_row = 0, prompt_col = 0 };
    }

    def echo_space(self: &mut Env) {
        self.echo(&" " as &Char);
    }

    def echo_newline(self: &mut Env) {
        self.echo_col = 0;
        self.echo(&"\r\n" as &Char);
    }

    def echo_tab(self: &mut Env) {
        self.echo(&"\t" as &Char);
    }

    def echo_solid_block(self: &mut Env, color: Color, flush: Bool) {
        // self.echo(&"█" as &Char);
        let str = [1 as Char, '\0'];
        // self.echo(&str as &Char);
        if flush {
            self.echo_colored(&str as &Char, color);
        } else {
            self.echo_colored_no_flush(&str as &Char, color);
        }
    }

    def echo_light_block(self: &mut Env, color: Color, flush: Bool) {
        // self.echo(&"▒" as &Char);
        let str = [2 as Char, '\0'];
        // self.echo(&str as &Char);
        if flush {
            self.echo_colored(&str as &Char, color);
        } else {
            self.echo_colored_no_flush(&str as &Char, color);
        }
    }

    def read_line(self: &mut Env, dst: &mut Char): Bool {
        when IS_RISCV {
            self.screen.keyboard.read();
            
            // Draw the entered text on the screen.
            if self.screen.keyboard.has_changed() {
                println("Keyboard has changed!");
                let (row, col) = self.echo_colored_at(self.screen.keyboard.buf, Color.YELLOW, self.prompt_row, self.prompt_col, True);
                // Write some spaces to clear the rest of the line.
                let _ = self.echo_colored_at(&"     " as &Char, Color.YELLOW, row, col, True);
            }

            if self.screen.keyboard.len <= 0 {
                // println("Buf: ", self.buf);
                // println("No line to read (len <= 0). (self=", *self, ")");
                return False;
            }

            // Clear the line on the screen.
            // self.screen.draw_some()
    
            if self.screen.keyboard.buf[self.screen.keyboard.len - 1] == '\n' {
                println("Read line: ", self.screen.keyboard.buf);
                // Copy the line into the destination buffer.
                for let mut i=0; i < self.screen.keyboard.len; i+=1 {
                    dst[i] = self.screen.keyboard.buf[i];
                }
                dst[self.screen.keyboard.len] = '\0';
                // Clear the keyboard buffer.
                self.screen.keyboard.clear();
                self.echo_newline();
                // extern strncpy(dst: &mut Char, src: &Char, n: Int);
                // strncpy(dst, self.screen.keyboard.buf,);
                
                // return Option<&Char> of Some(self.buf);
                return True;
            } else {
                // println("Buf: ", self.buf);
                // println("No line to read. (self=", *self, ")");
                return False;
            }
        } else {
            self.echo_newline();
            return self.screen.read_line(dst);
        }
    }

    def get_cwd(self: &Env): &Path {
        return &(self.cwd);
    }

    def prompt(self: &mut Env) {
        let mut prompt = SmolString.from_str(self.cwd.str());
        prompt.push_str(&"$ " as &Char);
        // // self.screen.write_str(prompt.str(), Color.WHITE, 0, self.echo_row * Bitmap.HEIGHT);
        // self.echo_col += prompt.len();
        if (self.echo_col != 0) {
            self.echo_newline();
        }
        self.echo(prompt.str());
        self.prompt_row = self.echo_row;
        self.prompt_col = self.echo_col;
    }

    def echo_coloredln(self: &mut Env, text: &Char, color: Color) {
        self.echo_colored(text, color);
        self.echo_newline();
    }

    def echo_colored_at(self: &mut Env, text: &Char, color: Color, mut row: Int, mut col: Int, flush: Bool): (Int, Int) {
        if row >= self.screen.height() / Bitmap.HEIGHT {
            row = 0;
            col = 0;
            self.screen.clear(Color.BLACK);
        }
    
        let (mut old_x, mut old_y) = (col * Bitmap.WIDTH, row * Bitmap.HEIGHT);
    
        let (new_x, new_y) = self.screen.write_str(text, color, Color.BLACK, old_x, old_y);
        col = new_x / Bitmap.WIDTH;
        row = new_y / Bitmap.HEIGHT;
        
        if flush {
            when IS_RISCV {
                // println("Echoing ", text, " at (", old_x, ", ", old_y, ") to (", new_x, ", ", new_y, ")");
                // def abs(x: Int): Int = if x < 0 { -x } else { x };
                // let mut width = abs(new_x - old_x);
                // let mut height = abs(new_y - old_y);

                // if new_x < old_x {
                //     width = abs(old_x - new_x);
                //     old_x = new_x;
                // }
                // if new_y < old_y {
                //     height = abs(old_y - new_y);
                //     old_y = new_y;
                //     width = self.screen.width();
                //     old_x = 0;
                // }

                // self.screen.draw_some(old_x, old_y, width, height);
                // self.screen.flush();
                self.screen.draw();
                self.screen.flush();
            } else {
                // If it ends with a newline
                self.screen.print();
            }
        }

        return (row, col);
    }

    def echo_colored_no_flush(self: &mut Env, text: &Char, color: Color) {
        let (new_row, new_col) = self.echo_colored_at(text, color, self.echo_row, self.echo_col, False);
        self.echo_row = new_row;
        self.echo_col = new_col;
    }

    def echo_colored(self: &mut Env, text: &Char, color: Color) {
        let (new_row, new_col) = self.echo_colored_at(text, color, self.echo_row, self.echo_col, True);
        self.echo_row = new_row;
        self.echo_col = new_col;
    }

    def echo(self: &mut Env, text: &Char) {
        self.echo_colored(text, Color.WHITE);
    }

    def echoln(self: &mut Env, text: &Char) {
        self.echo(text);
        self.echo_newline();
    }

    def get_cwd_mut(self: &mut Env): &mut Path {
        return &mut (self.cwd);
    }

    def get_os(self: &Env): &OS {
        return &(self.os);
    }

    def get_history(self: &Env): &History {
        return &(self.history);
    }

    def get_history_mut(self: &mut Env): &mut History {
        return &mut (self.history);
    }

    def print(self: &mut Env) {
        // println("Env: os=", self.os);
        // println("Env: cwd=", self.cwd);
        self.os.print_env(self).unwrap();
        self.history.echo(self);
    }

    def drop(self: &mut Env) {
        self.history.drop();
    }
}

let read = Symbol.from_str(&"cat" as &Char);
let static READ_SYMBOL: Symbol = read;
let write = Symbol.from_str(&"write" as &Char);
let static WRITE_SYMBOL: Symbol = write;
let append = Symbol.from_str(&"append" as &Char);
let static APPEND_SYMBOL: Symbol = append;
let copy = Symbol.from_str(&"cp" as &Char);
let static COPY_SYMBOL: Symbol = copy;
let remove = Symbol.from_str(&"rm" as &Char);
let static REMOVE_SYMBOL: Symbol = remove;
let make_dir = Symbol.from_str(&"mkdir" as &Char);
let static MAKE_DIR_SYMBOL: Symbol = make_dir;
let change_dir = Symbol.from_str(&"cd" as &Char);
let static CHANGE_DIR_SYMBOL: Symbol = change_dir;
let print_dir = Symbol.from_str(&"pwd" as &Char);
let static PRINT_DIR_SYMBOL: Symbol = print_dir;
let list_dir = Symbol.from_str(&"ls" as &Char);
let static LIST_DIR_SYMBOL: Symbol = list_dir;
let list_pid = Symbol.from_str(&"ps" as &Char);
let static LIST_PID_SYMBOL: Symbol = list_pid;
let list_mem = Symbol.from_str(&"mem" as &Char);
let static LIST_MEM_SYMBOL: Symbol = list_mem;
let help = Symbol.from_str(&"help" as &Char);
let static HELP_SYMBOL: Symbol = help;
let print_env = Symbol.from_str(&"env" as &Char);
let static PRINT_ENV_SYMBOL: Symbol = print_env;
let spawn = Symbol.from_str(&"spawn" as &Char);
let static SPAWN_SYMBOL: Symbol = spawn;

enum Error {
    PathNotFound(&Path),
    ProcessSpawnFailed(&Path)
}

impl Error {
    def print(self: &Error) {
        print("[Error] ");
        match self {
            &of PathNotFound(path) => {
                print("path not found: ");
                path.println();
            },
            _ => {
                println("Error: Error.print() called with invalid error.");
            }
        }
    }
}


impl Command {
    def eval(self: &Command, env: &mut Env): Result<(), Error> {
        print("Evaluating command: ");
        self.print();
        println();
        let os = env.get_os();
        match self {
            &of Read(path) => {
                let file = File.open(env.get_cwd(), FileMode of Read, env).expect(&"Could not open file." as &Char);
                let text = file.read(env).expect(&"Could not read from file." as &Char);
                // text.println();
                env.echo_coloredln(text.str(), Color.GREEN);
                file.close(env).expect(&"Could not close file." as &Char);
            },
            &of Write(path, text) => {
                let file = File.open(env.get_cwd(), FileMode of Write, env).expect(&"Could not open file." as &Char);
                file.write(text.str(), env).expect(&"Could not write to file." as &Char);
                file.close(env).expect(&"Could not close file." as &Char);
            },
            &of Append(path, text) => {
                let file = File.open(env.get_cwd(), FileMode of Append, env).expect(&"Could not open file." as &Char);
                file.write(text.str(), env).expect(&"Could not append to file." as &Char);
                file.close(env).expect(&"Could not close file." as &Char);
            },            
            &of Copy(src, dst) => {
                let src_path = Path.from_str(src.str());
                let dst_path = Path.from_str(dst.str());
                let src_file = File.open(&src_path, FileMode of Read, env).expect(&"Could not open source file." as &Char);
                let dst_file = File.open(&dst_path, FileMode of Write, env).expect(&"Could not open destination file." as &Char);
                let text = src_file.read(env).expect(&"Could not read from source file." as &Char);
                dst_file.write(text.str(), env).expect(&"Could not write to destination file." as &Char);
                src_file.close(env).expect(&"Could not close source file." as &Char);
                dst_file.close(env).expect(&"Could not close destination file." as &Char);
            },
            &of MakeDir(path) => {
                let path = Path.from_str(path.str());
                File.create_dir(&path, env).expect(&"Could not create directory." as &Char);
            },
            &of ChangeDir(mut name) => {
                // env.get_cwd_mut().push(path);
                let mut path = *(env.get_cwd());
                path.push(&mut name);
                if os.change_dir(env, &path).is_ok() {
                    env.get_cwd_mut().copy_from(&path);
                } else {
                    env.echo_coloredln(&"Could not change directory." as &Char, Color.RED);
                }
            },
            &of Spawn(mut name) => {
                // let path = Path.from_str(path.str());
                let mut path = *(env.get_cwd());
                path.push(&mut name);
                match os.spawn(env, &path) {
                    of Ok(pid) => {
                        // let mut str_buf = SmolString.from_str(&"Spawned process at " as &Char);
                        // str_buf.push_str(path.str());
                        // // Add space
                        // str_buf.push_str(&" " as &Char);
                        env.echo_colored(&"Spawned process at " as &Char, Color.GREEN);
                        env.echo_coloredln(path.str(), Color.BLUE);
                        env.echo_colored(&"PID = " as &Char, Color.GREEN);
                        let pid_str = SmolString.from_int(pid);
                        env.echo_colored(pid_str.str(), Color.MAGENTA);
                        env.echo_coloredln(&"!" as &Char, Color.GREEN);
                    },
                    of Err(e) => {
                        env.echo_coloredln(&"Could not spawn process!" as &Char, Color.RED);
                    }
                }
            },
            &of PrintDir => {
                // env.get_cwd().println();
                env.echoln(env.get_cwd().str());
            },
            &of ListDir => {
                // os.list_dir(env.get_cwd());
                File.list_dir(env.get_cwd(), env).expect(&"Could not list directory." as &Char);
                // dir.close(os);
            },
            &of ListPID => {
                os.list_pid(env).expect(&"Could not list PIDs." as &Char);
            },

            &of ListMem => {
                os.list_mem(env).expect(&"Could not list memory." as &Char);
            },
            &of PrintEnv => {
                env.print();
                // env.echo(&"Printing environment..." as &Char);
            },
            &of Help(symbol) => {
                if symbol.eq(&READ_SYMBOL) {
                    env.echoln(&"read <path>" as &Char);
                } elif symbol.eq(&WRITE_SYMBOL) {
                    env.echoln(&"write <path> <text>" as &Char);
                } elif symbol.eq(&APPEND_SYMBOL) {
                    env.echoln(&"append <path> <text>" as &Char);
                } elif symbol.eq(&COPY_SYMBOL) {
                    env.echoln(&"cp <src> <dst>" as &Char);
                } elif symbol.eq(&MAKE_DIR_SYMBOL) {
                    env.echoln(&"mkdir <path>" as &Char);
                } elif symbol.eq(&CHANGE_DIR_SYMBOL) {
                    env.echoln(&"cd <path>" as &Char);
                } elif symbol.eq(&PRINT_DIR_SYMBOL) {
                    env.echoln(&"pwd" as &Char);
                } elif symbol.eq(&LIST_DIR_SYMBOL) {
                    env.echoln(&"ls" as &Char);
                } elif symbol.eq(&LIST_PID_SYMBOL) {
                    env.echoln(&"ps" as &Char);
                } elif symbol.eq(&LIST_MEM_SYMBOL) {
                    env.echoln(&"mem" as &Char);
                } elif symbol.eq(&PRINT_ENV_SYMBOL) {
                    env.echoln(&"env" as &Char);
                } elif symbol.eq(&HELP_SYMBOL) {
                    env.echoln(&"help <command>" as &Char);
                } else {
                    env.echo_colored(&"Unknown help entry: " as &Char, Color.RED);
                    env.echoln(symbol.str());
                }
            },

            &of Invalid(s) => {
                env.echo_colored(&"Invalid command: " as &Char, Color.RED);
                env.echoln(s.str());
            },
            _ => {
                env.echo_coloredln(&"Error: Command.eval() called with invalid command." as &Char, Color.RED);
                // println("Error: Command.eval() called with invalid command.");
            }
        }

        return Result<(), Error> of Ok(());
    }

    def parse(s: &SmolString): Command {
        match s.nth_symbol(0) {
            of Some(program_str) => {
                println("Found program: ", program_str.str());
                if program_str.eq(&PRINT_DIR_SYMBOL) {
                    Command of PrintDir;
                } elif program_str.eq(&LIST_DIR_SYMBOL) {
                    Command of ListDir;
                } elif program_str.eq(&LIST_PID_SYMBOL) {
                    Command of ListPID;
                } elif program_str.eq(&LIST_MEM_SYMBOL) {
                    Command of ListMem;
                } elif program_str.eq(&PRINT_ENV_SYMBOL) {
                    Command of PrintEnv;
                } else {
                    match s.nth_symbol(1) {
                        of Some(arg_str) => {
                            println("Found argument: ", arg_str.str());
                            if program_str.eq(&COPY_SYMBOL) {
                                if let of Some(dst) = s.nth_symbol(2) {
                                    Command of Copy(arg_str, dst);
                                } else {
                                    Command of Invalid(*s);
                                }
                            } elif program_str.eq(&WRITE_SYMBOL) {
                                let mut s = *s;
                                s.trim_start(program_str.str());
                                s.trim_whitespace();
                                s.trim_start(arg_str.str());
                                s.trim_whitespace();
                                Command of Write(arg_str, s);
                            } elif program_str.eq(&APPEND_SYMBOL) {
                                let mut s = *s;
                                s.trim_start(program_str.str());
                                s.trim_whitespace();
                                s.trim_start(arg_str.str());
                                s.trim_whitespace();
                                Command of Append(arg_str, s);
                            } elif program_str.eq(&READ_SYMBOL) {
                                Command of Read(arg_str);
                            } elif program_str.eq(&MAKE_DIR_SYMBOL) {
                                Command of MakeDir(arg_str);
                            } elif program_str.eq(&SPAWN_SYMBOL) {
                                Command of Spawn(arg_str);
                            } elif program_str.eq(&CHANGE_DIR_SYMBOL) {
                                Command of ChangeDir(arg_str);
                            } elif program_str.eq(&HELP_SYMBOL) {
                                Command of Help(arg_str);
                            } else {
                                Command of Invalid(*s);
                            }
                        },
                        _ => Command of Invalid(*s)
                    }
                }
            },
            _ => {
                Command of Invalid(*s);
            }
        }
    }

    def print(self: &Command) {
        match self {
            &of Read(path) => {
                READ_SYMBOL.print();
                print(" ");
                path.println();
            },
            &of Write(path, text) => {
                WRITE_SYMBOL.print();
                print(" ");
                path.print();
                print(" ");
                text.println();
            },
            &of Append(path, text) => {
                WRITE_SYMBOL.print();
                print(" ");
                path.print();
                print(" ");
                text.println();
            },
            &of Copy(src, dst) => {
                COPY_SYMBOL.print();
                print(" ");
                src.print();
                print(" ");
                dst.println();
            },
            &of MakeDir(path) => {
                MAKE_DIR_SYMBOL.print();
                print(" ");
                path.println();
            },
            &of ChangeDir(path) => {
                CHANGE_DIR_SYMBOL.print();
                print(" ");
                path.println();
            },
            &of PrintDir => {
                PRINT_DIR_SYMBOL.println();
            },
            &of ListDir => {
                LIST_DIR_SYMBOL.println();
            },
            &of ListPID => {
                LIST_PID_SYMBOL.println();
            },
            &of ListMem => {
                LIST_MEM_SYMBOL.println();
            },
            &of PrintEnv => {
                PRINT_ENV_SYMBOL.println();
            },
            &of Help(symbol) => {
                HELP_SYMBOL.print();
                print(" ");
                symbol.println();
            },
            &of Invalid(s) => {
                print("Invalid command: ");
                s.println();
            },
            _ => {
                println("Error: Command.print() called with invalid command.");
            }
        }
    }

    def echo(self: &Command, env: &mut Env) {
        match self {
            &of Read(path) => {
                env.echo(READ_SYMBOL.str());
                env.echo_space();
                env.echoln(path.str());
            },
            &of Write(path, text) => {
                env.echo(WRITE_SYMBOL.str());
                env.echo_space();
                env.echo(path.str());
                env.echo_space();
                env.echoln(text.str());
            },
            &of Append(path, text) => {
                env.echo(APPEND_SYMBOL.str());
                env.echo_space();
                env.echo(path.str());
                env.echo_space();
                env.echoln(text.str());
            },
            &of Copy(src, dst) => {
                env.echo(COPY_SYMBOL.str());
                env.echo_space();
                env.echo(src.str());
                env.echo_space();
                env.echoln(dst.str());
            },
            &of MakeDir(path) => {
                env.echo(MAKE_DIR_SYMBOL.str());
                env.echo_space();
                env.echoln(path.str());
            },
            &of ChangeDir(path) => {
                env.echo(CHANGE_DIR_SYMBOL.str());
                env.echo_space();
                env.echoln(path.str());
            },
            &of PrintDir => {
                env.echoln(PRINT_DIR_SYMBOL.str());
            },
            &of ListDir => {
                env.echoln(LIST_DIR_SYMBOL.str());
            },
            &of ListPID => {
                env.echoln(LIST_PID_SYMBOL.str());
            },
            &of ListMem => {
                env.echoln(LIST_MEM_SYMBOL.str());
            },
            &of PrintEnv => {
                env.echoln(PRINT_ENV_SYMBOL.str());
            },
            &of Help(symbol) => {
                env.echo(HELP_SYMBOL.str());
                env.echo_space();
                env.echoln(symbol.str());
            },
            &of Invalid(s) => {
                env.echo(&"Invalid command: " as &Char);
                env.echoln(s.str());
            },
            _ => {
                println("Error: Command.print() called with invalid command.");
            }
        }
    }

    def println(self: &Command) {
        self.print();
        println();
    }
}

let input_buf = calloc<Char>(1024);

let mut screen = Screen.make({ x = 0, y = 0, width = 1280, height = 800 }, 2, 4);
when IS_RISCV {}
else {
    screen = Screen.make({ x = 0, y = 0, width = 1280, height = 800 }, 2, 8);
}
screen.clear(Color.BLACK);

def draw_logo(env: &mut Env) {
    // Draw the "Sage Shell" logo on the screen.

    // A 2d array of the logo, with each number representing a certain shape.
    let logo = [
        [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 6, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 12, 3, 4, 5, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 2, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 1, 1, 1, 2, 2, 1, 1, 1, 0, 1, 1, 1, 2, 2, 1, 1, 1, 0, 0, 0, 8, 0, 6, 7, 0, 0, 0, 0, 3, 5, 9, 5, 3, 0, 0, 0, 0, 0, 0],
        [0, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 2, 1, 1, 1, 0, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 8, 6, 3, 6, 3, 0, 11, 3, 4, 5, 3, 4, 14, 0, 3, 4, 5, 9],
        [0, 0, 2, 2, 2, 2, 1, 1, 1, 0, 1, 1, 1, 2, 2, 1, 1, 1, 0, 2, 1, 1, 1, 0, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 4, 3, 11, 9, 13, 0, 0, 3, 5, 4, 5, 9, 0, 3, 5, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 8, 13, 0, 9, 0, 3, 12, 9, 3, 5, 0, 0, 0],
        [0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 10, 0, 9, 13, 10, 8, 6, 3, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5, 13, 0, 6, 3, 6, 3, 5, 3, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4, 5, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];

    // # Define a mapping of characters to integers
    // char_to_int = {
    //     ' ': 0,  # empty space
    //     '█': 1,  # solid block
    //     '░': 2,  # light block
    //     '.': 3,  # dot
    //     '-': 4,  # horizontal line
    //     '\'': 5, # single quote
    //     '`': 6,  # backtick
    //     ',': 7,  # comma
    //     '\\': 8, # backslash
    //     '/': 9,  # forward slash
    //     '|': 10, # vertical bar
    //     ':': 11, # colon
    //     '_': 12, # underscore
    //     'o': 13, # lowercase 'o'
    //     '=': 14, # equals sign
    // }
    for let mut row = 0; row < sizeof(logo) / sizeof(logo[0]); row += 1 {
        for let mut col = 0; col < sizeof(logo[0]) / sizeof(logo[0][0]); col += 1 {
            match logo[row][col] {
                0 => {
                    env.echo_colored_no_flush(&" " as &Char, Color.BLACK);
                },
                1 => {
                    // env.echo_colored(&"█" as &Char, Color.GREEN);
                    env.echo_solid_block(Color.GREEN, False);
                },
                2 => {
                    // env.echo_colored(&"░" as &Char, Color.GREEN);
                    env.echo_light_block(Color.GREEN, False);
                },
                3 => {
                    env.echo_colored_no_flush(&"." as &Char, Color.GREEN);
                },
                4 => {
                    env.echo_colored_no_flush(&"-" as &Char, Color.GREEN);
                },
                5 => {
                    env.echo_colored_no_flush(&"'" as &Char, Color.GREEN);
                },
                6 => {
                    env.echo_colored_no_flush(&"`" as &Char, Color.GREEN);
                },
                7 => {
                    env.echo_colored_no_flush(&"," as &Char, Color.GREEN);
                },
                8 => {
                    env.echo_colored_no_flush(&"\\" as &Char, Color.GREEN);
                },
                9 => {
                    env.echo_colored_no_flush(&"/" as &Char, Color.GREEN);
                },
                10 => {
                    env.echo_colored_no_flush(&"|" as &Char, Color.GREEN);
                },
                11 => {
                    env.echo_colored_no_flush(&":" as &Char, Color.GREEN);
                },
                12 => {
                    env.echo_colored_no_flush(&"_" as &Char, Color.GREEN);
                },
                13 => {
                    env.echo_colored_no_flush(&"o" as &Char, Color.GREEN);
                },
                14 => {
                    env.echo_colored_no_flush(&"=" as &Char, Color.GREEN);
                },
                other => {
                    println("Error: Invalid logo character = ", other);
                    env.echo_colored_no_flush(&"?" as &Char, Color.RED);
                }
            }
        }
        // env.echo_newline();
        // env.echo_colored_no_flush(&"\r\n" as &Char, Color.GREEN);

        env.echo_col = 0;
        env.echo_colored_no_flush(&"\r\n" as &Char, Color.GREEN);
    }
    env.echo_newline();
}


let mut is_done = False;

let mut env = Env.make(screen);
// let logo = Bitmap.SAGE_LOGO;
// env.echo_coloredln(&logo as &Char, Color.GREEN);

env.echo_coloredln(&"Welcome to the Sage Shell!" as &Char, Color.MAGENTA);
env.echo_colored(&"Go to " as &Char, Color.MAGENTA);
env.echo_colored(&"adam-mcdaniel.net/sage", Color.BLUE);
env.echo_coloredln(&"!" as &Char, Color.MAGENTA);
env.echo_newline();

draw_logo(&mut env);

env.prompt();

while !is_done {
    if env.read_line(input_buf) {
        // env.echo_coloredln(input_buf, Color.YELLOW);
        println("Read line: ", input_buf);
        let s = SmolString.from_str(input_buf);
        println("About to parse: ", s.str());
        let command = Command.parse(&s);

        command.eval(&mut env).expect(&"Error evaluating command." as &Char);
        
        env.prompt();
    }
}
