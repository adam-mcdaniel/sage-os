/*
* Author: Adam McDaniel
* File: PPM.sg
* Created: 2023-12-8
* Short Desc: This is implements parsing and showing PPM files on our OS.
* Long Desc:
*     This is a simple PPM parser and viewer.
*     It is designed to be used on our OS.
*     It reads from a list of files and displays them.
*/

def malloc<T>(element_count: Int): &mut T {
    return alloc(element_count * sizeof<T>()) as &mut T;
}

def free<T>(ptr: &mut T) {
    del ptr;
}

struct Pixel {
    r: Int,
    g: Int,
    b: Int,
}

struct PPM {
    width: Int,
    height: Int,
    max_color_value: Int,
    pixels: &mut Pixel,
}

impl PPM {
    def make(width: Int, height: Int, max_color_value: Int, pixels: &mut Pixel): PPM {
        return {
            width=width,
            height=height,
            max_color_value=max_color_value,
            pixels=pixels
        };
    }

    def parse_ascii(content: &Char): Result<PPM, Error> {
        type Ret = Result<PPM, Error>;
        // Find the width and height
        let mut width: Int = 0;
        let mut height: Int = 0;
        let mut i: Int = 0;

        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }
        // Match against the `P6` magic number
        if content[i] != 'P' || content[i+1] != '3' {
            println("Magic number: ", content[i], content[i+1]);
            return Ret of Err(Error of InvalidMagicNumber);
        }
        i += 2;
        println("Magic number: ", content[0], content[1]);

        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }

        while content[i] != ' ' {
            width = width * 10 + content[i] as Int - '0' as Int;
            i += 1;
        }
        println("Width: ", width);

        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }

        while content[i] != '\n' {
            height = height * 10 + content[i] as Int - '0' as Int;
            i += 1;
        }
        println("Height: ", height);
        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }

        // Find the max color value
        let mut max_color_value: Int = 0;
        while content[i] != '\n' {
            max_color_value = max_color_value * 10 + content[i] as Int - '0' as Int;
            i += 1;
        }
        println("Max color value: ", max_color_value);

        let pixels = malloc<Pixel>(width * height);

        for let mut row=height - 1; row >= 0; row -= 1 {
            for let mut col=0; col < width; col += 1 {
                // Skip whitespace
                while content[i] == ' ' || content[i] == '\n' {
                    i += 1;
                }

                let mut r: Int = 0;
                while content[i] != ' ' {
                    r = r * 10 + content[i] as Int - '0' as Int;
                    i += 1;
                }

                // Skip whitespace
                while content[i] == ' ' || content[i] == '\n' {
                    i += 1;
                }

                let mut g: Int = 0;
                while content[i] != ' ' {
                    g = g * 10 + content[i] as Int - '0' as Int;
                    i += 1;
                }

                // Skip whitespace
                while content[i] == ' ' || content[i] == '\n' {
                    i += 1;
                }

                let mut b: Int = 0;
                while content[i] != ' ' && content[i] != '\n' && content[i] != '\0' {
                    b = b * 10 + content[i] as Int - '0' as Int;
                    i += 1;
                }

                pixels[row * width + col] = {
                    r=r,
                    g=g,
                    b=b
                };
            }
        }

        return Ret of Ok(PPM.make(width, height, max_color_value, pixels));
    }

    def parse_binary(content: &Char): Result<PPM, Error> {
        type Ret = Result<PPM, Error>;
        // Match against the `P6` magic number
        if content[0] != 'P' || content[1] != '6' {
            return Ret of Err(Error of InvalidMagicNumber);
        }
        println("Magic number: ", content[0], content[1]);

        // Find the width and height
        let mut width: Int = 0;
        let mut height: Int = 0;
        let mut i: Int = 3;

        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }

        while content[i] != ' ' {
            width = width * 10 + content[i] as Int - '0' as Int;
            i += 1;
        }
        println("Width: ", width);

        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }

        while content[i] != '\n' {
            height = height * 10 + content[i] as Int - '0' as Int;
            i += 1;
        }
        println("Height: ", height);
        // Skip whitespace
        while content[i] == ' ' || content[i] == '\n' {
            i += 1;
        }

        // Find the max color value
        let mut max_color_value: Int = 0;
        while content[i] != '\n' {
            max_color_value = max_color_value * 10 + content[i] as Int - '0' as Int;
            i += 1;
        }
        println("Max color value: ", max_color_value);

        let pixels = malloc<Pixel>(width * height);

        for let mut row=height - 1; row >= 0; row -= 1 {
            for let mut col=0; col < width; col += 1 {
                // Each pixel is a byte of red, green, and blue
                let r = content[i] as Int;
                i += 1;
                let g = content[i] as Int;
                i += 1;
                let b = content[i] as Int;
                i += 1;
                pixels[row * width + col] = {
                    r=r,
                    g=g,
                    b=b
                };
            }
        }

        return Ret of Ok(PPM.make(width, height, max_color_value, pixels));
    }

    def print(self: &PPM) {
        println("PPM: ", self.width, "x", self.height, " max color value: ", self.max_color_value);
        // for let mut row=0; row < self.height; row += 1 {
        for let mut row=self.height - 1; row >= 0; row -= 1 {
            for let mut col=0; col < self.width; col += 1 {
                let pixel = self.pixels[row * self.width + col];
                // print("(", pixel.r, ",", pixel.g, ",", pixel.b, ") ");
                // Draw the pixel in the terminal with escape codes
                let ESC = 27 as Char;
                print(ESC, "[48;2;", pixel.r, ";", pixel.g, ";", pixel.b, "m  ");
            }
            println("");
        }
    }
}

enum Error {
    InvalidMagicNumber,
    InvalidWidth,
    InvalidHeight,
    InvalidMaxColorValue,
    InvalidPixelData,
}

def remove_comments(content: &mut Char) {
    let mut i = 0;
    while content[i] != '\0' {
        if content[i] == '#' {
            while content[i] != '\n' {
                content[i] = ' ';
                i += 1;
            }
        }
        i += 1;
    }
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

def main() {
//     let mut ppm_ascii = "P3
// # \"P3\" means this is a RGB color image in ASCII
// # \"3 2\" is the width and height of the image in pixels
// # \"255\" is the maximum value for each color
// # This, up through the \"255\" line below are the header.
// # Everything after that is the image data: RGB triplets.
// # In order: red, green, blue, yellow, white, and black.
// 3 2
// 255
// 255   0   0
// 0 255   0
// 0   0 255
// 255 255   0
// 255 255 255
// 0   0   0";
    // let mut ppm_ascii = PPM_ASCII;
    println("PPM parser and viewer");
    extern get_file_size(file_name: &Char): Int;
    extern read_file(file_name: &Char, buffer: &mut Char, buffer_size: Int): Int;
    let file_name = "test.ppm";
    let file_size = get_file_size(&file_name);
    if file_size <= 0 {
        println("Error: file not found: ", file_name);
        return ();
    } else {
        println("File size: ", file_size);
    }

    let mut ppm_ascii = malloc<Char>(file_size);

    let file_size = read_file(&file_name, ppm_ascii, file_size);
    println("Read ", file_size, " bytes from file: ", file_name);

    // println("ASCII PPM:\n", ppm_ascii);
    remove_comments(ppm_ascii);
    // println("ASCII PPM (no comments):\n", ppm_ascii);
    
    match PPM.parse_ascii(ppm_ascii) {
        of Ok(ppm) => {
            println("Parsed ASCII PPM:\n", ppm);
            ppm.print();
        },
        of Err(err) => {
            println("Error parsing ASCII PPM: ", err);
        }
    }
}

main();